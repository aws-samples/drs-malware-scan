import json
import boto3

import os
import re
import sys
import time

def lambda_handler(events, context):
    """
    Kickoff GuardDuty malware scan of a given set of DRS source servers. This function is meant to be run regularly
    from the EventBridge scheduler. The function receives a JSON object containing a list of DRS source server names,
    i.e.,

    event: {
      'drs_source_servers': [
        'source server name 1',
        'source server name 2',
        ...
      ]
    }

    The function queries the DRS API to find out the id of the replicating instance which is replicating the on-prem
    data, and then starts malware scan by passing the ARN of this instance to the GuardDuty API. So, in order to be
    able to scan the source server the user must make sure that the DRS replication is in a healthy state, because
    otherwise the replicating instance may not exist. Please note that, at this moment, there is no public AWS API for
    scanning EBS snapshots generated by DRS.

    The function requires boto3 >= 1.26.165. Refer to the documentation for instructions to provide an updated version
    of boto3 using the lambda layers function of AWS Lambda.
    """

    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))

    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))

    #if ('drs_source_servers' not in events):
    #    print('error: usage:need drs_source_servers array in events object.')
    #    return {
    #        'statusCode': 300,
    #    }

    scan_count = 0
    scan_attempts = 0
    servers_count = 0
    error_count = 0
    drs_instances = {}

    # Iterate through the list of DRS source server names. For each source server, we will query the DRS API
    # to find out the id of the replicating EC2 instance. We'll buld an in-memory list of EC2 ids in order to
    # detect duplicates and avoid scanning the same instance twice. This is needed because the same instance
    # may be replicating multiple DRS source servers.
    for server_name in get_all_servers():
        servers_count += 1
        
        try:
            server_id = get_drs_source_server_id(server_name)
            # print('DRS source server {} has DRS id {}'.format(server_name, server_id))
            
            drs_instance_id = get_drs_instance_id(server_id)
            # print('DRS source server {} associated to replicating instance id {}'.format(server_name, drs_instance_id))
            
            if drs_instance_id is None:
                raise Exception('DRS source server {} not associated to a DRS replicating instance'.format(
                    server_name
                ))
            
            ebs_volumes = get_replitating_ebs_volume_ids(server_name, server_id)
            # print('DRS source server {} EBS volumes {}'.format(server_name, ebs_volumes))
            
            # For each replicating DRS instance, annotate the source server name(s) associated with it. We will need this 
            # information later to generate the order to the malware scan engine. We do not want to send a single order to
            # a given DRS instance in order to prevent errors, as GuardDuty does not allow more than one malware scan order
            # per EC2 instance per hour.
            if drs_instance_id in drs_instances:
                drs_instances[drs_instance_id][server_id] = {
                    'server_name': server_name,
                    'ebs_volumes': ebs_volumes,
                }
            else:
                drs_instances[drs_instance_id] = { 
                    server_id: {
                        'server_name': server_name,
                        'ebs_volumes': ebs_volumes,
                    }
                }
        except Exception as xcpt:
            error_count += 1
            print('error: {}'.format(
                xcpt
            ))

    # Now that we've got the list of replicating DRS instances, all we need to do is to instruct GuardDuty to
    # scan malware scanning by passing the EC2 ids to the scan operation - boto3.guardduty.start_malware_scan().
    #
    # To make things easier for the user, we will also annotate the id of the scan operation and the name of
    # the source DRS server(s) using a DynamoDB table. This information will be used at a later time to enrich
    # the related SecurityHub finding with the names of the DRS source servers containing malware files.
    
    for drs_instance_id, source_servers_dict in drs_instances.items():
        scan_attempts += 1
        
        try:
            # Kickoff malware scan for this replicating DRS instance.
            scan_drs_instance(drs_instance_id, source_servers_dict)
            
            # Success.
            scan_count += 1
        except Exception as xcpt:
            error_count += 1
            print('error: scan_drs_instance: {}'.format(
                xcpt
            ))
        finally:
            # GuardDuty rate limits the number of malware scan requests that can be initiated per second in
            # each AWS region. Currently, this rate-limited to a single EC2 instance per second. See [1] for
            # more information.
            #
            # [1] https://docs.aws.amazon.com/guardduty/latest/ug/malware-protection-limitations.html
            time.sleep(2)

    print('info: summary: {} DRS source servers, {} malware scan(s) attempted, {} initiated, {} error(s).'.format(
        servers_count,
        scan_attempts,
        scan_count,
        error_count,
    ))

    return {
        'statusCode': 200,
    }

def ebs_snap_with_drs_tags(ebs_snap):
    """
    This functions receives an object describing an EBS snapshot and validates that the snapshot is tagged appropriately.
    It checks for presence of both Name and AWSElasticDisasterRecoveryManaged tags, and corresponding values. These are
    used to sanity check the snapshots returned by the DRS API, the results of describe_snapshots() when it is applied to
    snapshot objects returned by the DRS API.
    """
    
    match = False
    match_key = False
    match_managed = False
    
    for tag in ebs_snap['Tags']:
        # Check Name and value.
        if tag['Key'] == 'Name':
            if tag['Value'] == 'AWS Elastic Disaster Recovery Snapshot':
                match_key = True;
            else:
                break
        
        # Validate AWSElasticDisasterRecoveryManaged and value.
        if tag['Key'] == 'AWSElasticDisasterRecoveryManaged':
            if tag['Value'] == 'drs.amazonaws.com':
                match_managed = True;
            else:
                break
    
    # Make sure both tags and values ares present.
    if match_key and match_managed:
        match = True
    
    return match

def ebs_volume_with_drs_tags(ebs_vol):
    """
    This functions receives an object describing an EBS volume and validates that it is tagged appropriately. It checks for 
    presence of both Name and AWSElasticDisasterRecoveryManaged tags, and corresponding values. These are used to sanity check
    the EBS volumes associated with snapshots returned by the DRS API.
    """

    match = False
    match_name = False
    match_managed = False

    for tag in ebs_vol['Tags']:
        # Check for Name and value.
        if tag['Key'] == 'Name':
            if tag['Value'] == 'AWS Elastic Disaster Recovery Replication Volume':
                match_name = True;
            else:
                break
        
        # Validate AWSElasticDisasterRecoveryManaged and value.
        if tag['Key'] == 'AWSElasticDisasterRecoveryManaged':
            if tag['Value'] == 'drs.amazonaws.com':
                match_managed = True;
            else:
                break

    if match_name and match_managed:
        match = True

    return match

def get_drs_instance_id_from_id(drs_source_server_id):
    """
    Obtain the id of the replicating EC2 instance associated with a given DRS source server identifier. This function
    queries the DRS, EC2, volumes and snapshot API to find the instance id, which is typically used at a later step to
    kickoff malware scan analysis. Roughly, it does:
    
    1. Query the DRS API to validate that the source server is healthy, and replicating continuouslly to AWS.
    2. Query again the DRS API to get details of a recent EBS snapshot performed by DRS for this source server.
    3. Checks that the DRS EBS snapshot is associated to a replicating EBS volume, and gets the id of it.
    4. Describe the replicating EBS volume to find the instance it is attached to. This is the replicating EC2 instance.
    
    Recall that currently, the only way to kickoff malware scan is pointing GuardDuty to a live EC2 instance, i.e., we
    don't have a public API to perform the analysis on an EB2 snapshot or DRS source server, so we go the long way and
    scan the replicating EC2 instance.
    
    Because the replicating EC2 instance can be associated to other DRS source servers, on- or off-prem, the related
    GuardDuty finding may or may not be associated to our DRS source server. This means that this solution must provide
    the mechanisms to let the end-user identify the correct outcome. Please bear this in mind to understand the annotations
    performed by this function and the rest of the steps performed everywhere else.
    """

    drs_client = boto3.client('drs')
    ec2_client = boto3.client('ec2')

    response = drs_client.describe_source_servers(
        filters={
            'sourceServerIDs': [
                drs_source_server_id,
            ],
        },
        maxResults=10
    )

    # print(json.dumps(response))
    source_server = response['items'][0]

    server_name = source_server['tags']['Name']                                             # e.g. w7x64
    server_id = source_server['sourceServerID']                                             # s-369f64697e68f21bf
    server_arn = source_server['arn']
    server_disk_count = len(source_server['sourceProperties']['disks'])                     # attached disk count
    server_hostname = source_server['sourceProperties']['identificationHints']['hostname']  # w7x64
    server_fqdn = source_server['sourceProperties']['identificationHints']['fqdn']          # w7x64
    server_replication_state = source_server['dataReplicationInfo']['dataReplicationState'] # STALLED

    # print('source server: {}'.format(server_name))
    # print('id: {}'.format(server_id))
    # print('arn: {}'.format(server_arn))
    # print('disks: {}'.format(server_disk_count))
    # print('hostname: {}'.format(server_hostname))
    # print('fqdn: {}'.format(server_fqdn))
    # print('replication state: {}'.format(server_replication_state))

    if (server_replication_state != 'CONTINUOUS'):
        # raise Exception('error: cannot scan source server {}: replication stalled, no replicating EC2 instance to scan'.format(
        #     server_name
        # ))
        print(('warning: DRS replication state is {} for source server {}. In order kickoff malware scan, we need the ' +
               'replicating EC2 instance id. If replication state is not {}, this instance may or may not exist. Please ' +
               'fix the DRS replication before attempting malware scan of this server.').format(
            server_replication_state,
            server_name,
            'CONTINUOUS'
        ))

    snapshots = drs_client.describe_recovery_snapshots(
        maxResults=20,
        order='DESC',
        sourceServerID=source_server['sourceServerID']
    )
    # print(json.dumps(snapshots))

    snap_found = False
    for snap in snapshots['items']:
        # print('snapshot id: {}'.format(snap['snapshotID']))
        # print('ebsSnapshots: {}'.format(len(snap['ebsSnapshots'])))
        snap_count = len(snap['ebsSnapshots'])
        if snap_count >= 1:
            snap_id = snap['ebsSnapshots'][0]
            snap_found = True
            break

    if snap_found == False:
        raise Exception('no snapshots found')

    ebs_snapshots = ec2_client.describe_snapshots(
        SnapshotIds=[
            snap_id,
        ],
    )

    ebs_snap_found = False
    for ebs_snap in ebs_snapshots['Snapshots']:
        # print('EBS snapshot id: {}'.format(ebs_snap['SnapshotId']))

        if ebs_snap_with_drs_tags(ebs_snap) == False:
            continue

        if ebs_snap['SnapshotId'] == snap_id:
            ebs_snap_found = True
            break

    if ebs_snap_found == False:
        raise Exception('cannot find EBS the snapshot')

    volume_description = ec2_client.describe_volumes(
        VolumeIds=[
            ebs_snap['VolumeId'],
        ]
    )
    ebs_volume = volume_description['Volumes'][0]

    if ('Attachments' not in ebs_volume
        or len(ebs_volume['Attachments']) != 1
        or ebs_volume['Attachments'][0]['State'] != 'attached'):
        raise Exception(('replicating EBS volume of source server {} is not attached to a DRS instance. Please fix DRS ' +
                         'replication before attempting malware scan on this server.').format(
            server_name
        ))

    if ebs_volume_with_drs_tags(ebs_volume) == False:
        raise Exception('cannot find the EBS volume')

    # print('DRS instance id: {}'.format(ebs_volume['Attachments'][0]['InstanceId']))
    return ebs_volume['Attachments'][0]['InstanceId']

def get_drs_source_server_id(source_server_name):
    """
    This funcion receives a name of an DRS source server queries the DRS API to get the DRS source server id. 
    For instance, if name is 'qubuntu', the result will be 's-3466cc584ed3dcf63' or None in case it is not found.
    """
    
    # Assume by thefault it is not found.
    source_server_id = None
    
    drs_client = boto3.client('drs')
    response = drs_client.describe_source_servers(
        maxResults=100
    )

    for server in response['items']:
        if server['tags']['Name'] == source_server_name:
            source_server_id = server['sourceServerID']

    return source_server_id

def get_drs_instance_id(name):
    """ 
    Get the EC2 id of the replicating DRS instance from a given DRS source server identifier. The identifier argument can be either
    a DRS source server name, or a DRS source server id. In the second case, the function will validate the given DRS source server
    id against the DRS API, and return the same id as a result. In any case, it will return None if not found.
    
    For example:
     
    o If name is 'qubuntu', the result will be 's-3466cc584ed3dcf63' or None in case it is not found.
    o If name is 's-3466cc584ed3dcf63', the result can be 's-3466cc584ed3dcf63' or None (in case the DRS API does not recognize it.
    """
    
    # Assume by default it is not found.
    drs_instance_id = None
    
    if not re.match('^s-[a-f0-9]+$', name):
        source_server_id = get_drs_source_server_id(name)
    else:
        source_server_id = name
    
    if source_server_id != None:
        # Now that we've got the DRS source server id (e.g. s-369f64697e68f21bf), try to get the id of the EC2 replicating
        # instance, if any. This instance may or may not exist, depending on the current state of the replication process.
        # During normal operation, this instance should be up & running.
        drs_instance_id = get_drs_instance_id_from_id(source_server_id)
    
    return drs_instance_id

def get_instance_arn(name):
    """
    Assemble the ARN of an EC2 instsance from a given instance name. For example:
    
    o When name is an ARN (i.e. it begins with 'arn:') it will be the identity operation.
    o When name is 'qubuntu' it returns arn:aws:ec2:us-east-1:607162100326:instance/i-f8416e0d06fa9803e.
    """
    
    instance_arn = name
    if not re.match('^arn:', name):
        ec2_instance_id = name
        boto3_session = boto3.session.Session()
        
        sts_client = boto3.client('sts')
        caller_identity = sts_client.get_caller_identity()
        
        instance_arn = 'arn:aws:ec2:{}:{}:instance/{}'.format(
            boto3_session.region_name,
            caller_identity['Account'],
            ec2_instance_id
        )
    
    return instance_arn

def get_replitating_ebs_volume_ids(drs_source_server_name, drs_source_server_id):
    """
    Get all of the replicating EBS volumes associated with a given DRS source server name and replicating EC2 instance.
    
    This function will query the DRS and EC2 APIs to generate an array containing the ids of all of the replicating EBS
    volumes of a healthy DRS source server. This information is critical to kickoff malware analysis and generate precise 
    annotations.
    
    Recall that when malware scan of a replicating EC2 instance triggers positively, we need to annotate the SecurityHub
    finding with the name of the DRS source server(s) containing malware that are also associated with that replicating
    DRS server. This is done by using the replicating EBS volume ids: the SecurityHub finding contains details of both 
    files and volume id(s) containing malware. By checking the ids of the EBS volumes against the annotations records, we
    can recover the context of the malware scan operation and find out the name of the infected DRS source server(s).
    
    At a high level, it:
    
    1. Queries the DRS API to get all of the snapshots id(s) of the replicating DRS source server.
    2. Queries the EC2 API to describe those snapshots and get detailed information. The details contain the EBS volume
       id associated to the snapshot. It then computes and return an array containing all of the EBS volume ids.
    """
    
    drs_client = boto3.client('drs')
    ec2_client = boto3.client('ec2')
    
    snapshots = drs_client.describe_recovery_snapshots(
        order='DESC',
        maxResults=20,
        sourceServerID=drs_source_server_id
    )
    
    snap_ids = None
    for snap in snapshots['items']:
        # print('snapshot id: {}'.format(snap['snapshotID']))
        # print('ebsSnapshots: {}'.format(len(snap['ebsSnapshots'])))
        snap_count = len(snap['ebsSnapshots'])
        if snap_count >= 1:
            snap_ids = snap['ebsSnapshots']
            break
    
    if snap_ids is None:
        raise Exception('no snapshots found')
    
    # print('DRS source server {} EBS snapshot id(s): {}'.format(
    #     drs_source_server_id,
    #     snap_ids
    # ))
    
    ebs_snapshots = ec2_client.describe_snapshots(SnapshotIds=snap_ids)['Snapshots']
    # print('DRS server {} EBS snapshots {}'.format(drs_source_server_name, ebs_snapshots))
    
    if (len(ebs_snapshots) != len(snap_ids)):
        raise Exception('cannot find matching EBS snapshots for DRS source server {}. ebs_snapshots {} snap_ids {}'.format(
            drs_source_server_name,
            ebs_snapshots,
            snap_ids
        ))
    
    ebs_volume_ids = [ebs_snapshot.get('VolumeId') for ebs_snapshot in ebs_snapshots]
    
    return ebs_volume_ids

def scan_drs_instance(drs_instance_id, source_servers_dict):
    """
    Perform malware scan of a given DRS instance. This function receives the instance id of a replicating DRS instance
    and Python dictionary describing its associated DRS source server(s). It will kickoff a GuardDuty malware scan over
    the replicating DRS instance and generate annotations describing the context of the scan operation. Annotations live
    on a related DynamoDB table, see annotate_scan_context() for more information on annotations.
    
    As explained elsewhere, annotations are critical to generate precise SecurityHub findings. Right now, the only way 
    to triger a malware scan operation is by pointing GuardDuty to a live EC2 instance. The replicating DRS server can
    map multiple DRS source server(s), so by the time the finding is created we need to have a way to identify which of
    the DRS source servers actually contains the identified malware. 
    """
    
    # Get the ARN of the replicating DRS instance.
    drs_instance_arn = get_instance_arn(drs_instance_id)

    # Generate a comma-separated string with the DRS source server id(s).
    source_servers_ids = ', '.join(list(source_servers_dict.keys()))
    
    try:
        # Kickoff malware scan over this instance.
        guardduty_client = boto3.client('guardduty')
        response = guardduty_client.start_malware_scan(
            ResourceArn=drs_instance_arn
        )
        
        # Dummy response for test purporses.
        #
        # response = {}
        # response['ScanId'] = '2304d11646ecb613e2f65e872c017197'

        malware_scan_timestamp = int(time.time())
    except Exception as xcpt:
        raise Exception('cannot start malware scan for DRS instance {} source server id [{}]: {}'.format(
            drs_instance_id,
            source_servers_ids,
            xcpt
        ))

    if 'ScanId' not in response:
        raise Exception('cannot start malware scan for DRS instance {}: no ScanId'.format(drs_instance_id))
    
    # Annotate the scan context using the DynamoDB table. It will be retrieved later to augment the SecurityHub finding.
    annotate_scan_context(drs_instance_id, source_servers_dict, response['ScanId'], malware_scan_timestamp)
    
    # Generate a log entry describing the DRS source servers connected to the replicating DRS instance.
    print('info: malware scan initiated for DRS instance {}, DRS scan id {}, source server id(s) [{}], timestamp {}.'.format(
        drs_instance_id,
        response['ScanId'],
        source_servers_ids,
        malware_scan_timestamp
    ));
    
    return True

def annotate_scan_context(drs_instance_id, source_servers_dict, scan_id, timestamp):
    """
    Document the context of a GuardDuty malware scan operation of a replicating DRS instance. This function receives the id of 
    the instance for which we performed a malware scan, and an Python dict describing the DRS source server(s) replicating to 
    the instance. It also receives the id of the scan operation that was just performed.
    
    It generates annotations describing the malware scan operation. For example:
    
    scan_id ebs_volume_id              ebs_volume_id           drs_instance_id       drs_source_server   malware_scan_timestamp
    ---------------------------------+-----------------------+---------------------+-------------------+-----------------------
    a6c26abb0c0c740dcb9be796e5db0949   vol-000316ad4021198f0   i-0c68fe9b7b229e27b   qubuntu             1690637540
    a6c26abb0c0c740dcb9be796e5db0949   vol-0755f1b8b83c52dc9   i-0c68fe9b7b229e27b   win7x64             1690637540
    a6c26abb0c0c740dcb9be796e5db0949   vol-04464c4d76c63e72e   i-0c68fe9b7b229e27b   EC2AMAZ-9PN01GE     1690637540
    a6c26abb0c0c740dcb9be796e5db0949   vol-0853e4519b16693ea   i-0c68fe9b7b229e27b   EC2AMAZ-9PN01GE     1690637540
    
    Using the id of the scan operation as a key, it documents all of the replicating EBS volumes associated with each of the
    DRS source server(s) described by source_servers_dict. When malware scan completes positively (later), these annotations
    can be retrieved by using the id(s) of the EBS volumes and the id of the scan operations. The related SecurityHub finding
    contains precise information of the file(s) and volume(s) containing malware, so with this context we can recover the
    DRS source server name(s) containing malware, and annotate the SecurituHub finding appropriately.
    """
    
    table_name = os.environ.get('ANNOTATIONS_TABLE')
    ddb_client = boto3.resource('dynamodb')
    annotations = ddb_client.Table(table_name)
    
    for source_server_id in source_servers_dict:
        source_server_name = source_servers_dict[source_server_id]['server_name']
        
        for ebs_volume_id in source_servers_dict[source_server_id]['ebs_volumes']:
            response = annotations.put_item(
                Item = {
                    'scan_id': scan_id,
                    'malware_scan_timestamp': timestamp,
                    'malware_scan_state': 'started',
                    'drs_instance_id': drs_instance_id,
                    'drs_source_server': source_server_name,
                    'drs_source_server_id': source_server_id,
                    'ebs_volume_id': ebs_volume_id,
                }
            )

    return True

def get_all_servers():
    table_name = os.environ.get('SERVERS_TABLE')
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table(table_name)
    
    drs_source_servers = []
    
    response = table.scan()
    items = response['Items']
    for item in items:
        drs_source_servers.append(item['server_name'])
    
    return drs_source_servers
