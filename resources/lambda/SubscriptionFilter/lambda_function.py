import os
import gzip
import json
import time
import base64

import boto3
import botocore

from DRSHelper import DRSHelper

drs_helper = DRSHelper()
event_time = None

def lambda_handler(events, context):
    """
    SubscriptionFilter updates the DynamoDB annotations to reflect the outcome of every malware scan operation submitted 
    by ProcessCommands.
    
    Currently, the GuardDuty malware scan APIs do not allow to identify the outcome of a scan operation individually, at
    the level of an EBS volume. Now consider the many-to-one relation between DRS source servers and the replicating DRS
    instance to which they are connected to: GuardDuty malware scan only provides a single outcome for the entire scan ops,
    so it is impossible to tell which DRS source server is infected in such escenario.
    
    To workaround this, ProcessOrder and ProcessCommands work closely to submit scan operations individually for each DRS 
    source server. As explained elsewhere, this is done by tagging the EBS volumes of the associated replicating instance, 
    in order to control which volumes to exclude from scanning. Only the volumes from the intended DRS source server get 
    analyzed for malware. 
    
    When the malware scan operation completes, GuardDuty logs the outcome of the malware operation through CloudWatch logs.
    A CloudWatch subscription filter triggers the lambda function, passing a compressed JSON object containing the message
    that was just logged. The function processes the JSON object, updating the DynamoDB annotations appropriately:
    
    1. EC2 instance annotations to track the status of every DRS replicating instance. Consider the many-to-one relation 
    between DRS source servers and the DRS replicating instances: this is needed in order to prevent racing against the same
    instace, i.e., to prevent concurrent malware scan operations mapped to the scame replicaing EC2. 
    
    2. EBS volume-level annotations. These are used to track the outcome of every malware scan operation and EBS volume 
    related to the DRS source server that was just scanned. This provides rudimentary reporting capabilities to the solution.
    """
    
    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))
    
    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))
    
    # Used to track the timestamp of completion of the malware scan operation that just finished.
    global event_time
    event_time = int(time.time())
    
    # Attempt to decode and decompress the CloudWatch log entry generated by GuardDuty malware scan.
    log_json = get_json_log(events['awslogs']['data'])
    malware_scan_events = get_malware_scan_events(log_json)
    
    # Process the outcome of the malware scan operation that just finished, updating annotations appropriately.
    for event in malware_scan_events:
        if (event['eventDetails']['eventType'] == 'EC2_SCAN_COMPLETED'):
            event_ec2_scan_completed(event)
        elif (event['eventDetails']['eventType'] == 'EC2_SCAN_SKIPPED'):
            event_ec2_scan_skipped(event)
    
    # Success.
    return {
        'statusCode': 200,
    }

def event_ec2_scan_completed(event):
    """
    Process a EC2_SCAN_COMPLETED type of event. This function updates the DRS instance annotations to keep track of the
    outcome of the operation, and also maintain a sense of time by generating timing annotations. It also updates the EB2 
    volume-level annotations appropriately.
    """
    
    event_details = event['eventDetails']
    # print('event_details: {}'.format(event_details))
    
    scan_details = event['scanRequestDetails']
    # print('scan_details: {}'.format(scan_details))
    
    resource_details = event['resourceDetails']
    # print('resource_details: {}'.format(resource_details))
    
    drs_instance_id = resource_details['instanceDetails']['instanceId']
    # print('drs_instance_id: {}'.format(drs_instance_id))
    
    ebs_volumes = resource_details['instanceDetails']['volumeDetailsList']
    # print('ebs_volumes: {}'.format(ebs_volumes))
    
    scan_status = event['scanResultsSummary']['scanResultStatus']
    # print('scan_status: {}'.format(scan_status))
    
    scan_id = scan_details['scanId']
    detector_id = event_details['detectorId']
    
    # Update DRS instance annotations to keep track of state & time.
    update_drs_instance(drs_instance_id)
    
    for ebs_volume in ebs_volumes:
        ebs_volume_id = ebs_volume['volumeId']
        
        if ('skipReason' not in ebs_volume):
            if (scan_status == 'CLEAN'):
                update_ebs_volume_clean(scan_id, ebs_volume_id)
            elif (scan_status == 'NOT_SCANNED'):
                update_ebs_volume_not_scanned(scan_id, ebs_volume_id)
            elif (scan_status == 'THREATS_FOUND'):
                update_ebs_volume_infected(scan_id, ebs_volume_id)
            else:
                print('error: unknown scan status {} related to scan id {}'.format(
                    scan_status, 
                    scan_id,
                ))
        else:
            if (ebs_volume['skipReason'] != 'EXCLUDED_BY_SCAN_SETTINGS'):
                update_ebs_volume_skipped(scan_id, ebs_volume_id, ebs_volume['skipReason'])

def event_ec2_scan_skipped(event):
    """
    Process a EC2_SCAN_SKIPPED type of event. This function updates the DRS instance annotations to keep track of the
    outcome of the operation, and also maintains a sense of time by annotating timing information. Also it updates EB2 volume
    annotations appropriately.
    """
    
    event_details = event['eventDetails']
    resource_details = event['resourceDetails']
    ebs_volumes = resource_details['instanceDetails']['volumeDetailsList']
    scan_details = event['scanRequestDetails']
    scan_id = scan_details['scanId']
    
    for ebs_volume in ebs_volumes:
        ebs_volume_id = ebs_volume['volumeId']
        
        if ('skipReason' not in ebs_volume):
            update_ebs_volume_skipped(scan_id, ebs_volume_id, None)
        else:
            if (ebs_volume['skipReason'] != 'EXCLUDED_BY_SCAN_SETTINGS'):
                update_ebs_volume_skipped(scan_id, ebs_volume_id, ebs_volume['skipReason'])

def update_ebs_volume_clean(scan_id, ebs_volume_id):
    update_ebs_volume_(scan_id, ebs_volume_id, 'completed', 'clean', event_time, None)

def update_ebs_volume_infected(scan_id, ebs_volume_id):
    update_ebs_volume_(scan_id, ebs_volume_id, 'completed', 'infected', event_time, None)

def update_ebs_volume_not_scanned(scan_id, ebs_volume_id):
    update_ebs_volume_(scan_id, ebs_volume_id, 'completed', 'not_scanned', event_time, None)

def update_ebs_volume_skipped(scan_id, ebs_volume_id, skip_reason):
    update_ebs_volume_(scan_id, ebs_volume_id, 'completed', 'skipped', event_time, skip_reason)

def update_ebs_volume_(scan_id, ebs_volume_id, scan_step, scan_result, scan_time, skip_reason):
    if (skip_reason is None):
        skip_reason = 'n/a'
    
    try:
        drs_helper.ddb_client().update_item(
            TableName = os.environ.get('DDB_DRS_VOLUME_ANNOTATIONS'),
            ExpressionAttributeNames = {
                '#SS': 'scan_step',
                '#SR': 'scan_result',
                '#ST': 'scan_time_end',
                '#SK': 'skip_reason',
            },
            ExpressionAttributeValues = {
                ':ss': {
                    'S': scan_step,
                },
                ':sr': {
                    'S': scan_result,
                },
                ':st': {
                    'N': str(scan_time),
                },
                ':sk': {
                    'S': skip_reason,
                },
            },
            Key = {
                'scan_id': {
                    'S': scan_id,
                }, 
                'ebs_volume_id': {
                    'S': ebs_volume_id,
                },
            },
            ConditionExpression = 'attribute_exists(scan_id)',
            UpdateExpression = 'SET #SS = :ss, #SR = :sr, #ST = :st, #SK = :sk',
            ReturnValues = 'ALL_NEW',
        )
    except drs_helper.ddb_client().exceptions.ConditionalCheckFailedException:
        print(('error: no annotations found for ebs_volume {} scan_id {}').format(
            ebs_volume_id,
            scan_id,
        ))

def update_drs_instance(drs_instance_id):
    update_drs_instance_(drs_instance_id, 'completed', event_time)

def update_drs_instance_(drs_instance_id, scan_step, scan_time):
    try:
        result = drs_helper.ddb_client().update_item(
            TableName = os.environ.get('DDB_DRS_INSTANCE_ANNOTATIONS'),
            ExpressionAttributeNames = {
                '#SS': 'scan_step',
                '#ST': 'scan_time_end',
            },
            ExpressionAttributeValues = {
                ':ss': {
                    'S': scan_step,
                },
                ':st': {
                    'N': str(scan_time),
                },
            },
            Key = {
                'drs_instance_id': {
                    'S': drs_instance_id,
                }, 
            },
            ConditionExpression = 'attribute_exists(drs_instance_id)',
            UpdateExpression = 'SET #SS = :ss, #ST = :st',
            ReturnValues = 'ALL_NEW',
        )
    except drs_helper.ddb_client().exceptions.ConditionalCheckFailedException:
        print('error: no annotations found for DRS instance {}'.format(
            drs_instance_id,
        ))

def get_malware_scan_events(log_json):
    """
    Generate a Python dict representing the scan event that was just logged by GuardDuty through CloudWatch logs.
    """
    
    malware_scan_events = []
    
    # Make sure to only process the outcome of GuardDuty malware scan operations.
    if (log_json['logGroup'] == '/aws/guardduty/malware-scan-events'):
        for log_event in log_json['logEvents']:
            log_message = json.loads(log_event['message'])
            malware_scan_events.append(log_message)
    
    # Success.
    return malware_scan_events    

def get_json_log(log_data_z64):
    """
    Decompress the log information provided by the CloudWatch subscription filter.
    """
    
    log_data_z = base64.b64decode(log_data_z64)
    log_data = gzip.decompress(log_data_z)
    # print('log_data: {}'.format(log_data))
    
    log_json = json.loads(log_data)
    # print('log_json: {}'.format(str(log_json)))
    
    return log_json
