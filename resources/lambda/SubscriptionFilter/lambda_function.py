import os
import gzip
import json
import time
import base64

import boto3
import botocore

from DRSHelper import DRSHelper

drs_helper = DRSHelper()
event_time = None

def lambda_handler(events, context):
    """
    TBD
    """

    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))

    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))

    global event_time
    event_time = int(time.time())
    
    log_json = get_json_log(events['awslogs']['data'])
    malware_scan_events = get_malware_scan_events(log_json)
    
    for event in malware_scan_events:
        if (event['eventDetails']['eventType'] == 'EC2_SCAN_COMPLETED'):
            event_ec2_scan_completed(event)
        elif (event['eventDetails']['eventType'] == 'EC2_SCAN_SKIPPED'):
            event_ec2_scan_skipped(event)
        
    return {
        'statusCode': 200,
    }

def event_ec2_scan_completed(event):
    event_details = event['eventDetails']
    # print('event_details: {}'.format(event_details))
    
    scan_details = event['scanRequestDetails']
    # print('scan_details: {}'.format(scan_details))
    
    resource_details = event['resourceDetails']
    # print('resource_details: {}'.format(resource_details))
    
    drs_instance_id = resource_details['instanceDetails']['instanceId']
    # print('drs_instance_id: {}'.format(drs_instance_id))
    
    ebs_volumes = resource_details['instanceDetails']['volumeDetailsList']
    # print('ebs_volumes: {}'.format(ebs_volumes))
    
    scan_status = event['scanResultsSummary']['scanResultStatus']
    # print('scan_status: {}'.format(scan_status))
    
    scan_id = scan_details['scanId']
    detector_id = event_details['detectorId']
    
    # Update DRS instance annotations to keep track of state & time.
    update_drs_instance(drs_instance_id)
    
    for ebs_volume in ebs_volumes:
        ebs_volume_id = ebs_volume['volumeId']
        
        if ('skipReason' not in ebs_volume):
            if scan_status == 'CLEAN':
                update_ebs_volume_clean(scan_id, ebs_volume_id)
            elif scan_status == 'NOT_SCANNED':
                update_ebs_volume_not_scanned(scan_id, ebs_volume_id)
            elif scan_status == 'THREATS_FOUND':
                update_ebs_volume_infected(scan_id, ebs_volume_id)
            else:
                print('error: unknown scan status {} related to scan id {}'.format(
                    scan_status, 
                    scan_id,
                ))
        else:
            if (ebs_volume['skipReason'] != 'EXCLUDED_BY_SCAN_SETTINGS'):
                update_ebs_volume_skipped(scan_id, ebs_volume_id, ebs_volume['skipReason'])

def event_ec2_scan_skipped(event):
    event_details = event['eventDetails']
    resource_details = event['resourceDetails']
    ebs_volumes = resource_details['instanceDetails']['volumeDetailsList']
    scan_details = event['scanRequestDetails']
    scan_id = scan_details['scanId']
    
    for ebs_volume in ebs_volumes:
        ebs_volume_id = ebs_volume['volumeId']
        
        if ('skipReason' not in ebs_volume):
            update_ebs_volume_skipped(scan_id, ebs_volume_id, None)
        else:
            if (ebs_volume['skipReason'] != 'EXCLUDED_BY_SCAN_SETTINGS'):
                update_ebs_volume_skipped(scan_id, ebs_volume_id, ebs_volume['skipReason'])

def update_ebs_volume_clean(scan_id, ebs_volume_id):
    update_ebs_volume_(scan_id, ebs_volume_id, 'completed', 'clean', event_time, None)

def update_ebs_volume_infected(scan_id, ebs_volume_id):
    update_ebs_volume_(scan_id, ebs_volume_id, 'completed', 'infected', event_time, None)

def update_ebs_volume_not_scanned(scan_id, ebs_volume_id):
    update_ebs_volume_(scan_id, ebs_volume_id, 'completed', 'not_scanned', event_time, None)

def update_ebs_volume_skipped(scan_id, ebs_volume_id, skip_reason):
    update_ebs_volume_(scan_id, ebs_volume_id, 'completed', 'skipped', event_time, skip_reason)

def update_ebs_volume_(scan_id, ebs_volume_id, scan_step, scan_result, scan_time, skip_reason):
    if (skip_reason is None):
        skip_reason = 'n/a'
    
    try:
        drs_helper.ddb_client().update_item(
            TableName = os.environ.get('DDB_DRS_VOLUME_ANNOTATIONS'),
            ExpressionAttributeNames = {
                '#SS': 'scan_step',
                '#SR': 'scan_result',
                '#ST': 'scan_time_end',
                '#SK': 'skip_reason',
            },
            ExpressionAttributeValues = {
                ':ss': {
                    'S': scan_step,
                },
                ':sr': {
                    'S': scan_result,
                },
                ':st': {
                    'N': str(scan_time),
                },
                ':sk': {
                    'S': skip_reason,
                },
            },
            Key = {
                'scan_id': {
                    'S': scan_id,
                }, 
                'ebs_volume_id': {
                    'S': ebs_volume_id,
                },
            },
            ConditionExpression = 'attribute_exists(scan_id)',
            UpdateExpression = 'SET #SS = :ss, #SR = :sr, #ST = :st, #SK = :sk',
            ReturnValues = 'ALL_NEW',
        )
    except drs_helper.ddb_client().exceptions.ConditionalCheckFailedException:
        print(('error: no annotations found for ebs_volume {} scan_id {}').format(
            ebs_volume_id,
            scan_id,
        ))

def update_drs_instance(drs_instance_id):
    update_drs_instance_(drs_instance_id, 'completed', event_time)

def update_drs_instance_(drs_instance_id, scan_step, scan_time):
    try:
        result = drs_helper.ddb_client().update_item(
            TableName = os.environ.get('DDB_DRS_INSTANCE_ANNOTATIONS'),
            ExpressionAttributeNames = {
                '#SS': 'scan_step',
                '#ST': 'scan_time_end',
            },
            ExpressionAttributeValues = {
                ':ss': {
                    'S': scan_step,
                },
                ':st': {
                    'N': str(scan_time),
                },
            },
            Key = {
                'drs_instance_id': {
                    'S': drs_instance_id,
                }, 
            },
            ConditionExpression = 'attribute_exists(drs_instance_id)',
            UpdateExpression = 'SET #SS = :ss, #ST = :st',
            ReturnValues = 'ALL_NEW',
        )
    except drs_helper.ddb_client().exceptions.ConditionalCheckFailedException:
        print('error: no annotations found for DRS instance {}'.format(
            drs_instance_id,
        ))

def get_malware_scan_events(log_json):
    malware_scan_events = []
    
    if (log_json['logGroup'] == '/aws/guardduty/malware-scan-events'):
        for log_event in log_json['logEvents']:
            log_message = json.loads(log_event['message'])
            malware_scan_events.append(log_message)
    
    return malware_scan_events    

def get_json_log(log_data_z64):
    log_data_z = base64.b64decode(log_data_z64)
    log_data = gzip.decompress(log_data_z)
    # print('log_data: {}'.format(log_data))
    
    log_json = json.loads(log_data)
    # print('log_json: {}'.format(str(log_json)))
    
    return log_json
