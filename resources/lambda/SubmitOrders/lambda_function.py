import os
import json
import boto3
import random

from DRSHelper import DRSHelper

drs_helper = DRSHelper()

def lambda_handler(events, context):
    """
    Kickoff GuardDuty malware scan for a given set of DRS source servers. This function is meant to be run regularly, e.g. 
    from an EventBridge schedule. The function queries DynamoDB to get a list of DRS source servers to perform malware scan
    through the DDB_SOURCE_SERVERS_TABLE environment variable. It queries the DRS API to find out the id of the replicating
    instance which is replicating the on-prem data, then submits the malware scan orders through an SQS queue for further 
    processing (SQS_SCAN_ORDERS_URL).

    Please note that, at this moment, there is no public AWS API for scanning EBS snapshots generated by DRS. The user must
    make sure that the DRS replication is in a healthy state before attempting the malware scan. Otherwise, the replicating
    instance may not exist. 
    """

    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))

    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))

    error_count = 0
    servers_count = 0
    scan_count = 0
    scan_attempts = 0
    scan_orders = []
    
    # Iterate through the list of DRS source server names extracted from DynamoDB. For each source server, we will query the
    # DRS API to find out the id of the replicating EC2 instance. We will then build a malware scan order and submit it for 
    # further processing through the orders queue pointed by SQS_SCAN_ORDERS_URL (environment variable).
    for server_name in get_drs_source_servers():
        servers_count += 1
        
        try:
            # Get the id of the given DRS source server name (i.e. "qubuntu" => "s-36af64097").
            server_id = drs_helper.get_drs_source_server_id(server_name)
            
            if (server_id is None):
                 raise Exception('cannot retrieve the source server id of your DRS server name {}. Make ' +
                                 'sure that the name is correctly set up in the DynamoDB table {}.'.format(
                    server_name,
                    os.environ.get('DDB_SOURCE_SERVERS_TABLE'),
                ))
            
            # Get the id of the replicating DRS instance, i.e. "s-36af64097" => "i-0c68fe002xxx".
            drs_instance_id = drs_helper.get_drs_instance_id(server_id)
            # print('DRS source server {} associated to replicating instance id {}'.format(server_name, drs_instance_id))
            
            if (drs_instance_id is None):
                raise Exception('DRS source server {} not associated to a DRS replicating instance.'.format(
                    server_name,
                ))
            
            # Get the list of replicating EBS volumes associated to this DRS source server.
            ebs_volumes = drs_helper.get_replicating_ebs_volume_ids(server_name, server_id)
            # print('DRS source server {} EBS volumes {}'.format(server_name, ebs_volumes))
            
            # Build an in-memory array of malware scan orders. We will submit them soon using SQS (below).
            scan_orders.append({
                'source_server_id': server_id,
                'source_server_name': server_name,
                'drs_instance_id': drs_instance_id,
            })
        except Exception as xcpt:
            error_count += 1
            print('error: {}'.format(
                xcpt
            ))
    
    for scan_order in scan_orders:
        scan_attempts += 1
        
        try:
            # Submit the order downstream for further processing: ultimately, the solution must invoke GuardDuty malware scan
            # through the API passing the ARN of the replicating instance. However, because of the way the existing APIs work,
            # malware scan operations cannot run concurrently if they map to the same DRS replicating instance. The solution
            # uses an SQS FIFO queue to serialize these requests and prevent race conditions. Refer to the documentation of the
            # ProcessOrders function for more informaiton.
            submit_scan_order(scan_order)
            
            # Success.
            scan_count += 1
        except Exception as xcpt:
            error_count += 1
            print('error: submit_scan_order: {}'.format(
                xcpt
            ))
    
    print('info: summary: {} DRS source servers, {} malware scan(s) attempted, {} initiated, {} error(s).'.format(
        servers_count,
        scan_attempts,
        scan_count,
        error_count,
    ))
    
    return {
        'statusCode': 200,
    }

def submit_scan_order(scan_order):
    """
    Submit a malware scan order downstream using SQS. This function receives a Python dictionary describing the order,
    and submits it to the SQS FIFO queue pointed by the SQS_SCAN_ORDERS_URL environment variable.
    
    As explained elsewhere, the solution SQS FIFO queue to serialize requests and prevent race conditions. Refer to the
    documentation of the ProcessOrders function for more informaiton.
    """
    
    response = drs_helper.sqs_client().send_message(
        QueueUrl = os.environ.get('SQS_SCAN_ORDERS_URL'),
        MessageBody = json.dumps({
            'source_server_id': scan_order['source_server_id'],
            'source_server_name': scan_order['source_server_name'],
        }),
        MessageDeduplicationId = str(random.random()),
        MessageGroupId = scan_order['drs_instance_id'],
    )
    
    # print('send_message: {} queue {}'.format(
    #     str(response),
    #     os.environ.get('SQS_SCAN_ORDERS_URL'),
    # ))
    
    # Paranoia check the HTTP status code of the SQS response.
    if (response['ResponseMetadata']['HTTPStatusCode'] != 200):
        raise Exception('cannot submit malware scan command through SQS queue {}: HTTPStatusCode {}'.format(
            os.environ.get('SQS_SCAN_ORDERS_URL'),
            response['ResponseMetadata']['HTTPStatusCode'],
        ))
    
    return True

def get_drs_source_servers():
    """
    Query the DynamoDB servers table to get all of the DRS source server name(s) managed by the solution.
    """
    
    drs_source_servers = []
    response = drs_helper.ddb_client().scan(
        TableName = os.environ.get('DDB_SOURCE_SERVERS_TABLE'),
    )
    items = response['Items']
    for item in items:
        drs_source_servers.append((item['server_name']['S']).strip())
    
    return drs_source_servers

if (__name__ == "__main__"):
    with open("/dev/stdin") as file:
        events = json.load(file)
    lambda_handler(events, '')
