import os
import json
import boto3
import random

from DRSHelper import DRSHelper

drs_helper = DRSHelper()

def lambda_handler(events, context):
    """
    Kickoff GuardDuty malware scan of a given set of DRS source servers. This function is meant to be run regularly
    from the EventBridge scheduler. The function receives a JSON object containing a list of DRS source server names,
    i.e.,

    event: {
      'drs_source_servers': [
        'source server name 1',
        'source server name 2',
        ...
      ]
    }

    The function queries the DRS API to find out the id of the replicating instance which is replicating the on-prem
    data, and then starts malware scan by passing the ARN of this instance to the GuardDuty API. So, in order to be
    able to scan the source server the user must make sure that the DRS replication is in a healthy state, because
    otherwise the replicating instance may not exist. Please note that, at this moment, there is no public AWS API for
    scanning EBS snapshots generated by DRS.

    The function requires boto3 >= 1.26.165. Refer to the documentation for instructions to provide an updated version
    of boto3 using the lambda layers function of AWS Lambda.
    """

    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))

    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))

    error_count = 0
    servers_count = 0
    scan_count = 0
    scan_attempts = 0
    scan_orders = []
    
    # Iterate through the list of DRS source server names. For each source server, we will query the DRS API
    # to find out the id of the replicating EC2 instance. We'll buld an in-memory list of EC2 ids in order to
    # detect duplicates and avoid scanning the same instance twice. This is needed because the same instance
    # may be replicating multiple DRS source servers.
    for server_name in get_drs_source_servers():
        servers_count += 1
        
        try:
            server_id = drs_helper.get_drs_source_server_id(server_name)
            # print('DRS source server {} has DRS id {}'.format(server_name, server_id))
            
            if (server_id is None):
                 raise Exception('cannot retrieve the source server id of your DRS server name {}. Please check'.format(
                    server_name,
                ))

            drs_instance_id = drs_helper.get_drs_instance_id(server_id)
            # print('DRS source server {} associated to replicating instance id {}'.format(server_name, drs_instance_id))
            
            if (drs_instance_id is None):
                raise Exception('DRS source server {} not associated to a DRS replicating instance'.format(
                    server_name,
                ))
            
            ebs_volumes = drs_helper.get_replicating_ebs_volume_ids(server_name, server_id)
            # print('DRS source server {} EBS volumes {}'.format(server_name, ebs_volumes))

            scan_orders.append({
                'source_server_id': server_id,
                'source_server_name': server_name,
                'drs_instance_id': drs_instance_id,
            })
        except Exception as xcpt:
            error_count += 1
            print('error: {}'.format(
                xcpt
            ))
    
    # Now that we've got the list of replicating DRS instances, all we need to do is to instruct GuardDuty to
    # scan malware scanning by passing the EC2 ids to the scan operation - boto3.guardduty.start_malware_scan().
    #
    # To make things easier for the user, we will also annotate the id of the scan operation and the name of
    # the source DRS server(s) using a DynamoDB table. This information will be used at a later time to enrich
    # the related SecurityHub finding with the names of the DRS source servers containing malware files.
    
    for scan_order in scan_orders:
        scan_attempts += 1
        
        try:
            # Kickoff malware scan for this replicating DRS instance.
            submit_scan_order(scan_order)
            
            # Success.
            scan_count += 1
        except Exception as xcpt:
            error_count += 1
            print('error: submit_scan_order: {}'.format(
                xcpt
            ))

    print('info: summary: {} DRS source servers, {} malware scan(s) attempted, {} initiated, {} error(s).'.format(
        servers_count,
        scan_attempts,
        scan_count,
        error_count,
    ))

    return {
        'statusCode': 200,
    }

def submit_scan_order(scan_order):
    """
    Perform malware scan of a given DRS instance. This function receives the instance id of a replicating DRS instance
    and Python dictionary describing its associated DRS source server(s). It will kickoff a GuardDuty malware scan over
    the replicating DRS instance and generate annotations describing the context of the scan operation. Annotations live
    on a related DynamoDB table, see annotate_scan_context() for more information on annotations.
    
    As explained elsewhere, annotations are critical to generate precise SecurityHub findings. Right now, the only way 
    to triger a malware scan operation is by pointing GuardDuty to a live EC2 instance. The replicating DRS server can
    map multiple DRS source server(s), so by the time the finding is created we need to have a way to identify which of
    the DRS source servers actually contains the identified malware. 
    """
    
    response = drs_helper.sqs_client().send_message(
        QueueUrl = os.environ.get('SQS_SCAN_ORDERS_URL'),
        MessageBody = json.dumps({
            'source_server_id': scan_order['source_server_id'],
            'source_server_name': scan_order['source_server_name'],
        }),
        MessageDeduplicationId = str(random.random()),
        MessageGroupId = scan_order['drs_instance_id'],
    )
    
    # print('send_message: {} queue {}'.format(
    #     str(response),
    #     os.environ.get('SQS_SCAN_ORDERS_URL'),
    # ))
    
    if (response['ResponseMetadata']['HTTPStatusCode'] != 200):
        raise Exception('cannot submit malware scan command through SQS queue {}: HTTPStatusCode {}'.format(
            os.environ.get('SQS_SCAN_ORDERS_URL'),
            response['ResponseMetadata']['HTTPStatusCode'],
        ))
    
    return True

def get_drs_source_servers():
    """
    Query the DynamoDB servers table to get all of the DRS source server name(s) managed by the solution.
    """
    
    drs_source_servers = []
    response = drs_helper.ddb_client().scan(
        TableName = os.environ.get('DDB_SOURCE_SERVERS_TABLE'),
    )
    items = response['Items']
    for item in items:
        drs_source_servers.append((item['server_name']['S']).strip())
    
    return drs_source_servers

if (__name__ == "__main__"):
    with open("/dev/stdin") as file:
        events = json.load(file)
    lambda_handler(events, '')
