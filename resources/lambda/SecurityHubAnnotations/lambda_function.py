import os
import json
import time
import boto3

from DRSHelper import DRSHelper

drs_helper = DRSHelper()
securityhub_client = None

def lambda_handler(events, context):
    """
    Annotate SecurityHub findings coming from GuardDuty Malware Scan. We want to agument these findings by annotating the DRS
    source server name & id to the it. This function is meant to be triggered by a SecurityHub events rule.
    
    The function receives a JSON object containing a list of findings, filtering out those that are not related to the intent
    mentioned above. Then, the function generates a note containing both the DRS source server name and id related to the malware
    scan finding. This note can be accessed by security operations team through SecurityHub to quickly identify the DRS source
    server containing malware threats.
    """
    
    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))
    
    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))
    
    # Initialize.
    findings = events['detail']['findings']
    
    # Iterate through the findings reported in this event.
    for finding in events['detail']['findings']:
        product_arn = finding['ProductArn']
        product_fields = finding['ProductFields']
        scan_id_path = 'aws/guardduty/service/ebsVolumeScanDetails/scanId'
        
        # Filter out findings not related to GuardDuty.
        if (product_arn != 'arn:aws:securityhub:us-east-1::product/aws/guardduty'):
            continue
        
        # Also, filter out findings without a scan id number.
        if (scan_id_path not in product_fields):
            continue
        
        # Extract relevant fields: scan_id, resource_id, finding_id. These are needed to annotate the SecurityHub finding.
        scan_id = product_fields[scan_id_path]
        resource_id = events['resources'][findings.index(finding)]
        guardduty_finding_id = finding['Id']
        
        # print('debug: scan id: {}'.format(scan_id))
        # print('debug: resource id: {}'.format(resource_id))
        # print('debug: guardduty finding id: {}'.format(guardduty_finding_id))
        
        try:
            # Annotate the SecurityHub finding with the DRS source server name and id containing malware.
            update_securityhub_finding(scan_id, resource_id, product_arn, guardduty_finding_id)
        except Exception as ex:
            print('error: {}'.format(ex))
    
    return {
        'statusCode': 200,
    }

def update_securityhub_finding(scan_id, resource_id, product_arn, guardduty_finding_id):
    """
    Annotate a given SecurityHub finding generated from GuardDuty malware scan. Then, the function generates a note field in the
    SecurityHub finding. Note contains both the DRS source server name and id related to the malware scan operation. This note can
    be accessed by security operations team through SecurityHub to quickly identify the DRS source server containing malware.
    """
    
    global securityhub_client
    drs_source_server_text = ''
    drs_source_servers = []
    
    # Retrieve the EBS volume-level annotations related to this scan operation.
    drs_source_servers = query_drs_volumes_table(scan_id)
    # print('debug: drs_source_servers = {}'.format(drs_source_servers))
    
    # Initialize the SecurityHub client.
    if (securityhub_client is None):
        securityhub_client = boto3.client('securityhub')
    
    # Paranoia check: we assert that every malware scan operation triggering a positive thread finding must relate to a single DRS
    # source server. Rationale: because of current limitations in the GuardDuty malware scan API, and the many-to-one relation that
    # exists between the DRS source servers and associated DRS replicating instance, there is no way to tell the individual outcome
    # of a malware scan operation performen over multiple DRS source servers. As explained elsewhere, the solution workarounds this
    # by scanning a given DRS source server at a time, excluding other source servers mapped to the same replicating instance using
    # GuardDutyExcluded tags.
    if (len(drs_source_servers) == 1):
        drs_source_server_text = '{} ({})'.format(
            drs_source_servers[0]['drs_source_server_name'],
            drs_source_servers[0]['drs_source_server_id'],
        )
    else:
        drs_source_server_text = 'No annotations made. Please report this error.'
    
    # XXX Perform the update operation using batch updates.
    response = securityhub_client.batch_update_findings(
        FindingIdentifiers=[{
            'Id': guardduty_finding_id,
            'ProductArn': product_arn,
        }],
        Note = {
            'Text': drs_source_server_text,
            'UpdatedBy': 'DRS Source Server',
        }
    )
    
    # Paranoia check: make sure that get get a positive HTTP status code.
    if (response['ResponseMetadata']['HTTPStatusCode'] != 200):
        raise('cannot update SecurityHub finding id {}'.format(
            guardduty_finding_id,
        ))
    
    # Finally, generate a CloudWatch log message describing the outcome of the scan operation.
    print('info: updated SecurityHub finding id {} set DRS source server to: {}.'.format(
        guardduty_finding_id,
        drs_source_server_text,
    ))

def query_drs_volumes_table(scan_id):
    """
    Extract all of the relevant information needed to annotate a given SecurityHub finding describing a positive malware scan
    operation: DRS source server name(s) and id(s). Normally, because of the way the current solution architecture works, the 
    function will return a single name and source server id. In case it is left to the caller to assert or not this behavior.
    """
    
    drs_source_servers = []
    drs_source_server_ids = {}
    
    response = drs_helper.ddb_client().query(
        TableName = os.environ.get('DDB_DRS_VOLUME_ANNOTATIONS'),
        ExpressionAttributeValues = {
            ':scan_id': {
                'S': scan_id,
            },
        },
        KeyConditionExpression = 'scan_id = :scan_id',
    )
    
    if (response['ResponseMetadata']['HTTPStatusCode'] != 200):
        raise Exception('cannot query DRS volumes table using scan_id {}: dynamodb client returned with HTTP status code {}'.format(
            scan_id,
            response['ResponseMetadata']['HTTPStatusCode'],
        ))
    
    if ('Items' not in response):
        raise Exception('cannot query DRS volumes table using scan_id {}: no Items attribute present in response'.format(
            scan_id,
        ))
    
    if (len(response['Items']) == 0):
        raise Exception('cannot query DRS volumes table using scan_id {}: zero Items in response'.format(
            scan_id,
        ))
    
    for item in response['Items']:
        server_name = item['drs_source_server']['S']
        server_id = item['drs_source_server_id']['S']
        
        if (server_id in drs_source_server_ids):
            continue
        
        drs_source_servers.append({
            'drs_source_server_id': server_id,
            'drs_source_server_name': server_name,
        })
        drs_source_server_ids[server_id] = server_name
    
    return drs_source_servers

if (__name__ == "__main__"):
    with open("/dev/stdin") as file:
        events = json.load(file)
    lambda_handler(events, '')
