import re
import os

import json
import time
import boto3

from DRSHelper import DRSHelper

event_time = None
drs_helper = DRSHelper()

def lambda_handler(events, context):
    """
    TBD
    """
    
    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))
    
    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))

    global event_time
    event_time = int(time.time())
    
    try:
        scan_command = read_scan_command(events)
        print_scan_command(scan_command)
        exec_scan_command(scan_command)
        annotate_scan_command(scan_command)
        delete_scan_command(scan_command)
    except:
        raise
    
    # XXX
    if ((time.time() - event_time) <= 1):
        time.sleep(1)
    
    result = {
        'batchItemFailures': [],
    }
    
    return result

def read_scan_command(events):
    """
    TBD
    """
    
    # Initialize.
    scan_command = {}
    
    if (len(events['Records']) != 1):
        raise Exception('read_scan_command() received an invalid records count of {}'.format(
            len(events['Records']),
        ))
    
    scan_command['sqs_message_id'] = events['Records'][0]['messageId']
    scan_command['sqs_receipt_handle'] = events['Records'][0]['receiptHandle']
    
    message_body = json.loads(events['Records'][0]['body'])
    scan_command['source_server_id'] = message_body['source_server_id']
    scan_command['source_server_name'] = message_body['source_server_name']
    scan_command['drs_instance_arn'] = message_body['drs_instance_arn']
    scan_command['drs_instance_id'] = message_body['drs_instance_id']
    scan_command['ebs_volumes'] = message_body['ebs_volumes']

    # Record the message id to remove the record from SQS.
    scan_command['sqs_message_id'] = events['Records'][0]['messageId']
        
    return scan_command

def print_scan_command(scan_command):
    text = ''

    text += 'source_server_id {}'.format(
        scan_command['source_server_id']
    )
    
    text += ' source_server_name {}'.format(
        scan_command['source_server_name']
    )
    
    text += ' drs_instance_arn {}'.format(
        scan_command['drs_instance_arn']
    )
    
    text += ' ebs_volumes {}'.format(
        scan_command['ebs_volumes']
    )
    
    text += ' sqs_receipt_handle {}'.format(
        scan_command['sqs_receipt_handle']
    )
    
    print('debug: scan_command: {}'.format(text))

def exec_scan_command(scan_command):
    # Kickoff malware scan over this instance.
    guardduty_client = boto3.client('guardduty')
    
    response = guardduty_client.start_malware_scan(
        ResourceArn = scan_command['drs_instance_arn'],
    )
    
    if ('ScanId' not in response):
        raise Exception('cannot start malware scan for DRS instance {}: no ScanId'.format(
            scan_command['drs_instance_id']
        ))
    
    scan_command['scan_time'] = int(event_time)
    scan_command['scan_id'] = response['ScanId']

def annotate_scan_command(scan_command):
    annotate_ec2_instance(scan_command)
    annotate_ebs_volumes(scan_command)

def annotate_ec2_instance(scan_command):
    """
    Update the annotations of the DRS instance for which we just kicked off GuardDuty malware scan. This function assumes
    that the annotation record already exists, and updates both the scan_step and scan_time_start fields:
    
    o scan_step is set to 'init' at order creation time. Here, we set to 'started'.
    o scan_time is also set at order creatime time, updated here with the current time stamp.
    """
    
    result = drs_helper.ddb_client().update_item(
        TableName = os.environ.get('DDB_DRS_INSTANCE_ANNOTATIONS'),
        Key = {
            'drs_instance_id': {
                'S': scan_command['drs_instance_id'],
            }, 
        },
        ExpressionAttributeNames = {
            '#SS': 'scan_step',
            '#SID': 'scan_id',
            '#STS': 'scan_time_start',
        },
        ExpressionAttributeValues = {
            ':ss': {
                'S': 'started',
            },
            ':sid': {
                    'S': scan_command['scan_id'],
            },
            ':sts': {
                'N': str(scan_command['scan_time']),
            },
        },
        UpdateExpression = 'SET #SS = :ss, #SID = :sid, #STS = :sts',
        ReturnValues = 'ALL_NEW',
    )
    
    print('debug: annotate_ec2_instance: dynamodb.update_item(): {}'.format(result))

def annotate_ebs_volumes(scan_command):
    """
    Document the EBS volumes a GuardDuty malware scan operation. This function receives the scan_command object describing the
    malware scan operation that was just kicked off, including the scan_id parameter describing the operation id that was just 
    performed.
    
    It generates annotations describing the EBS volumes of the malware scan operation. For example:
    
    scan_id     ebs_volume_id           drs_instance_id       drs_source_server   scan_time        scan_tate   drs_server_volume
    ----------+-----------------------+---------------------+-------------------+----------------+-----------+------------------
    a6c26abbc   vol-000316ad4021198f0   i-0c68fe9b7b229e27b   qubuntu             1690637540       started     false
    a6c26abbc   vol-0755f1b8b83c52dc9   i-0c68fe9b7b229e27b   win7x64             1690637540       started     false
    a6c26abbc   vol-04464c4d76c63e72e   i-0c68fe9b7b229e27b   EC2AMAZ-9PN01GE     1690637540       started     false
    a6c26abbc   vol-0853e4519b16693ea   i-0c68fe9b7b229e27b   EC2AMAZ-9PN01GE     1690637540       started     false
    a6c26abbc   vol-0853e4519b16693ef   i-0c68fe9b7b229e27b                       1690637540       started     true

    Using the id of the scan operation as a key, it documents all of the replicating EBS volumes associated with each of the
    DRS source server(s) described by scan_command. When malware scan completes, later, these annotations can be retrieved and
    updated using the id(s) of the EBS volumes and the id of the scan operation.
    """
    
    for ebs_volume_id in scan_command['ebs_volumes']:
        response = drs_helper.ddb_client().put_item(
            TableName = os.environ.get('DDB_DRS_VOLUME_ANNOTATIONS'),
            Item = {
                'scan_id': {
                    'S': scan_command['scan_id'],
                }, 
                'ebs_volume_id': {
                    'S': ebs_volume_id,
                },
                'scan_time_start': {
                    'N': str(scan_command['scan_time']),
                },
                'scan_step': {
                    'S': 'started',
                },
                'scan_result': {
                    'S': 'n/a',
                },
                'drs_instance_id': {
                    'S': scan_command['drs_instance_id'],
                },
                'drs_source_server': {
                    'S': scan_command['source_server_name'],
                },
                'drs_source_server_id': {
                    'S': scan_command['source_server_id'],
                },
            }
        )
        
        print('debug: annotate_ebs_volumes: dynamodb.put_item(): {}'.format(response))

def delete_scan_command(scan_command):
    response = drs_helper.sqs_client().delete_message(
        QueueUrl = os.environ.get('SQS_SCAN_COMMANDS_URL'),
        ReceiptHandle = scan_command['sqs_receipt_handle'],
    )
    
    print('debug: delete_scan_command: sqs.delete_message(): {}'.format(str(response)))

if (__name__ == "__main__"):
    with open("/dev/stdin") as file:
        events = json.load(file)
    lambda_handler(events, '')
