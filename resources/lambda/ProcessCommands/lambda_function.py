import re
import os

import json
import time
import boto3

from DRSHelper import DRSHelper

event_time = None
drs_helper = DRSHelper()

def lambda_handler(events, context):
    """
    ProcessCommands submits malware scan operations through the GuardDuty API. It receives a malware scan command containing
    all of the necessary information to invoke the scan operation. Malware scan commands are generated by ProcessOrders, and
    submitted to ProcessCommands through an SQS FIFO queue (SQS_SCAN_COMMANDS_URL).
    
    The function assumes that (1) the replicating DRS instance is available for a malware scan operation, and (2) that every
    attached EBS volume are appropriately tagged with the GuardDutyExcluded tag. This means that every EBS volume that is not
    related to the target DRS source server instance is tagged with GuardDutyExcluded tag set to 'true'. It also assumes that
    the tags do not change through the entire lifecycle of the malware scan operation: it is the reposibility of ProcessOrders
    to tag the EBS volumes appropriately and avoid manipulating them while the scan operation is in flight.
    
    After the malware scan operation is submitted through the GuardDuty API, 
    
    1. It updates the DRS instance annotations (environment variable DDB_DRS_INSTANCE_ANNOTATIONS) to set the tracking status
    to 'started'. This prevents ProcessOrders from racing against the EBS volume tags, as explained above. 
    
    2. It also updated the annotations at the EBS volume levels (DDB_DRS_VOLUME_ANNOTATIONS) to track the outcome of every
    EBS volume related to the target DRS source server.
    
    3. Deletes the scan command from the source SQS FIFO queue. Deletion is done explicitly in order to provide resiliency, 
    in case it gets throttled by the GuardDuty API. 
    
    4. It makes sure to align with the existing API rate of 1 scan operation per second from GuardDuty malware scan. This is
    done by using a single messageGroupId for all of the malware scan commands submitted through ProcessCommands, maintaining
    a sense of time to pause synchrously when needed.
    
    Exceptions are logged and the operation remains on the SQS_SCAN_COMMANDS_URL to retry and provide resiliency.
    """
    
    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))
    
    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))
    
    # Used to annotate timing information into the scan command we are about to create.
    global event_time
    event_time = int(time.time())
    
    try:
        # Get a single malware scan command from the SQS FIFO.
        scan_command = read_scan_command(events)
        
        # Uncomment the line below for additional debugging.
        # print_scan_command(scan_command)
        
        # If we get to this point, we are ready to execute the malware scan command and trigger GuardDuty malware scan. We assert
        # there are no concurrent malware scan operations in flight. 
        exec_scan_command(scan_command)
        
        # Now that the scan operation was sent to GuardDuty, rack in-flight operation at the level of the replicating DRS instance
        # by performing annotations using a DynamoDB table pointed by DDB_DRS_INSTANCE_ANNOTATIONS. The related EBS volumes will be
        # tracked using DDB_DRS_VOLUME_ANNOTATIONS.
        annotate_scan_command(scan_command)
        
        # Sucess. Delete the command from the source SQS FIFO queue.
        delete_scan_command(scan_command)
    except:
        raise
    
    # Avoid hammering the GuardDuty malware scan more than once per second. Malware scan commands are grouped using a single
    # SQS FIFO messageGroupId parameter, so that all of the queued commands stay in the queue while we sleep synchronously.
    if ((time.time() - event_time) <= 1):
        time.sleep(1)
    
    # Success. Remove the malware scan command from SQS_MALWARE_SCAN_COMMANDS_URL.
    result = {
        'batchItemFailures': [],
    }
    
    return result

def read_scan_command(events):
    """
    Get a single malware scan command from the SQS FIFO. This function parses the SQS event message to extract a malware
    scan command submitted by the ProcessOrders lambda. At this stage, the malware scan command contains all of the relevant
    information needed to invoke GuardDuty malware scan. The function parses these attributes and builds a dict modeling the
    scan command.
    """
    
    # Initialize.
    scan_command = {}
    
    # Sanity check. As explained elsewhere, ProcessCommands does one malware scan command at a time.
    if (len(events['Records']) != 1):
        raise Exception('read_scan_command() received an invalid records count of {}'.format(
            len(events['Records']),
        ))
    
    # These are needed in case we need to retry this command at a later stage, i.e. to increase resiliency to temporary 
    # errors. Also to remove the record from the SQS_MALWARE_SCAN_COMMANDS_URL in case of success as well.
    scan_command['sqs_message_id'] = events['Records'][0]['messageId']
    scan_command['sqs_receipt_handle'] = events['Records'][0]['receiptHandle']
    
    # Extract relevant attributes: id and name of the DRS source server to which we want to perform malware scan to, id and
    # ARN of the replicating DRS instance, list of EBS volumes related to the DRS source server to be scanned.
    message_body = json.loads(events['Records'][0]['body'])
    scan_command['source_server_id'] = message_body['source_server_id']
    scan_command['source_server_name'] = message_body['source_server_name']
    scan_command['drs_instance_arn'] = message_body['drs_instance_arn']
    scan_command['drs_instance_id'] = message_body['drs_instance_id']
    scan_command['ebs_volumes'] = message_body['ebs_volumes']
    
    # Record the message id to remove the record from SQS.
    scan_command['sqs_message_id'] = events['Records'][0]['messageId']
    
    # Success.
    return scan_command

def print_scan_command(scan_command):
    text = ''

    text += 'source_server_id {}'.format(
        scan_command['source_server_id']
    )
    
    text += ' source_server_name {}'.format(
        scan_command['source_server_name']
    )
    
    text += ' drs_instance_arn {}'.format(
        scan_command['drs_instance_arn']
    )
    
    text += ' ebs_volumes {}'.format(
        scan_command['ebs_volumes']
    )
    
    text += ' sqs_receipt_handle {}'.format(
        scan_command['sqs_receipt_handle']
    )
    
    print('debug: scan_command: {}'.format(text))

def exec_scan_command(scan_command):
    """
    Submit a malware scan operation through the GuardDuty API. This means asserting the following invariants:
    
    1. No other malware scan operations are concurrent to the one we are about to submit.
    
    2. EBS volume tags generated by ProcessOrders remain immutable through the entire scan operation (GuardDutyExcluded tag).
    """
    
    # Kickoff malware scan over this instance.
    guardduty_client = boto3.client('guardduty')
    
    response = guardduty_client.start_malware_scan(
        ResourceArn = scan_command['drs_instance_arn'],
    )
    
    # XXX Sanity check paranoia.
    if ('ScanId' not in response):
        raise Exception('cannot start malware scan for DRS instance {}: no ScanId'.format(
            scan_command['drs_instance_id']
        ))
    
    scan_command['scan_time'] = int(event_time)
    scan_command['scan_id'] = response['ScanId']

def annotate_scan_command(scan_command):
    """
    This function is the single high-level method to produce all of the relevant annotations at the DRS replicating instance 
    level, as well as at the EBS volume level to track the status of every EBS volume related to the DRS source server that the
    malware scan command refert to.
    """
    
    annotate_ec2_instance(scan_command)
    annotate_ebs_volumes(scan_command)

def annotate_ec2_instance(scan_command):
    """
    Update the annotations of the DRS instance for which we just kicked off GuardDuty malware scan. This function assumes
    that the annotation record already exists, and updates both the scan_step and scan_time_start fields:
    
    1. scan_step is set to 'init' at order creation time. Here, we set to 'started'.
    
    2. scan_time is also set at order creatime time, updated here with the current time stamp.
    """
    
    result = drs_helper.ddb_client().update_item(
        TableName = os.environ.get('DDB_DRS_INSTANCE_ANNOTATIONS'),
        Key = {
            'drs_instance_id': {
                'S': scan_command['drs_instance_id'],
            }, 
        },
        ExpressionAttributeNames = {
            '#SS': 'scan_step',
            '#SID': 'scan_id',
            '#STS': 'scan_time_start',
        },
        ExpressionAttributeValues = {
            ':ss': {
                'S': 'started',
            },
            ':sid': {
                    'S': scan_command['scan_id'],
            },
            ':sts': {
                'N': str(scan_command['scan_time']),
            },
        },
        UpdateExpression = 'SET #SS = :ss, #SID = :sid, #STS = :sts',
        ReturnValues = 'ALL_NEW',
    )
    
    print('debug: annotate_ec2_instance: dynamodb.update_item(): {}'.format(result))

def annotate_ebs_volumes(scan_command):
    """
    Document the EBS volumes a GuardDuty malware scan operation. This function receives the scan_command object describing the
    malware scan operation that was just kicked off, including the scan_id parameter describing the operation id that was just 
    performed.
    
    It generates annotations describing the EBS volumes of the malware scan operation. For example:
    
    scan_id     ebs_volume_id           drs_instance_id       drs_source_server   scan_time        scan_tate   drs_server_volume
    ----------+-----------------------+---------------------+-------------------+----------------+-----------+------------------
    a6c26abbc   vol-000316ad4021198f0   i-0c68fe9b7b229e27b   qubuntu             1690637540       started     false
    a6c26abbc   vol-0755f1b8b83c52dc9   i-0c68fe9b7b229e27b   win7x64             1690637540       started     false
    a6c26abbc   vol-04464c4d76c63e72e   i-0c68fe9b7b229e27b   EC2AMAZ-9PN01GE     1690637540       started     false
    a6c26abbc   vol-0853e4519b16693ea   i-0c68fe9b7b229e27b   EC2AMAZ-9PN01GE     1690637540       started     false
    a6c26abbc   vol-0853e4519b16693ef   i-0c68fe9b7b229e27b                       1690637540       started     true

    Using the id of the scan operation as a key, it documents all of the replicating EBS volumes associated with each of the
    DRS source server(s) described by scan_command. When malware scan completes, later, these annotations can be retrieved and
    updated using the id(s) of the EBS volumes and the id of the scan operation.
    """
    
    for ebs_volume_id in scan_command['ebs_volumes']:
        response = drs_helper.ddb_client().put_item(
            TableName = os.environ.get('DDB_DRS_VOLUME_ANNOTATIONS'),
            Item = {
                'scan_id': {
                    'S': scan_command['scan_id'],
                }, 
                'ebs_volume_id': {
                    'S': ebs_volume_id,
                },
                'scan_time_start': {
                    'N': str(scan_command['scan_time']),
                },
                'scan_step': {
                    'S': 'started',
                },
                'scan_result': {
                    'S': 'n/a',
                },
                'drs_instance_id': {
                    'S': scan_command['drs_instance_id'],
                },
                'drs_source_server': {
                    'S': scan_command['source_server_name'],
                },
                'drs_source_server_id': {
                    'S': scan_command['source_server_id'],
                },
            }
        )
        
        print('debug: annotate_ebs_volumes: dynamodb.put_item(): {}'.format(response))

def delete_scan_command(scan_command):
    """
    Remove a scan command message from the source SQS FIFO.
    """
    
    response = drs_helper.sqs_client().delete_message(
        QueueUrl = os.environ.get('SQS_SCAN_COMMANDS_URL'),
        ReceiptHandle = scan_command['sqs_receipt_handle'],
    )
    
    print('debug: delete_scan_command: sqs.delete_message(): {}'.format(str(response)))

if (__name__ == "__main__"):
    with open("/dev/stdin") as file:
        events = json.load(file)
    lambda_handler(events, '')
