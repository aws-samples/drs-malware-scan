import re
import os

import json
import boto3

class ExDRSInstanceBusy(Exception):
    pass

class DRSHelper:
    def __init__(self):
        self.ddb_client_ = None
        self.drs_client_ = None
        self.ec2_client_ = None
        self.sqs_client_ = None
        self.sts_client_ = None

    def get_drs_source_server_id(self, source_server_name):
        """
        This method receives a name of an DRS source server queries the DRS API to get the DRS source server id. 
        For instance, if name is 'qubuntu', the result will be 's-3466cc584ed3dcf63' or None in case it is not found.
        """
        
        # Assume by default it is not found.
        source_server_id = None
        
        response = self.drs_client().describe_source_servers(
            maxResults = 100
        )
        
        for server in response['items']:
            if (server['tags']['Name'] == source_server_name):
                source_server_id = server['sourceServerID']
        
        return source_server_id
    
    def get_drs_instance_id(self, name):
        """ 
        Get the EC2 id of the replicating DRS instance from a given DRS source server identifier. The identifier argument can be 
        either a DRS source server name, or a DRS source server id. In the second case, the function will validate the given DRS 
        source server id against the DRS API, and return the same id as a result. In any case, it will return None if not found.
        
        For example:
         
        o If name is 'qubuntu', the result will be 's-3466cc584ed3d' or None in case it is not found.
        o If name is 's-3466cc584ed3d', the result can be 's-3466cc584ed3d' or None (in case the DRS API does not recognize it.
        """
        
        # Assume by default it is not found.
        drs_instance_id = None
        
        if (not re.match('^s-[a-f0-9]+$', name)):
            source_server_id = self.get_drs_source_server_id(name)
        else:
            source_server_id = name
        
        if (source_server_id != None):
            # Now that we've got the DRS source server id (e.g. s-369f64697e68f21bf), try to get the id of the EC2 replicating
            # instance, if any. This instance may or may not exist, depending on the current state of the replication process.
            # During normal operation, this instance should be up & running.
            drs_instance_id = self.get_drs_instance_id_from_id_(source_server_id)
        
        return drs_instance_id
    
    def get_replicating_ebs_volume_ids(self, drs_source_server_name, drs_source_server_id):
        """
        Get all of the replicating EBS volumes associated with a given DRS source server name and replicating EC2 instance.
        
        This method will query the DRS and EC2 APIs to generate an array containing the ids of all of the replicating EBS
        volumes of a healthy DRS source server. This information is critical to kickoff malware analysis and generate precise 
        annotations.
        
        Recall that when malware scan of a replicating EC2 instance triggers positively, we need to annotate the SecurityHub
        finding with the name of the DRS source server(s) containing malware that are also associated with that replicating
        DRS server. This is done by using the replicating EBS volume ids: the SecurityHub finding contains details of both 
        files and volume id(s) containing malware. By checking the ids of the EBS volumes against the annotations records, we
        can recover the context of the malware scan operation and find out the name of the infected DRS source server(s).
        
        At a high level, it:
        
        1. Queries the DRS API to get all of the snapshots id(s) of the replicating DRS source server.
        2. Queries the EC2 API to describe those snapshots and get detailed information. The details contain the EBS volume
           id associated to the snapshot. It then computes and return an array containing all of the EBS volume ids.
        """
        
        snapshots = self.drs_client().describe_recovery_snapshots(
            order = 'DESC',
            maxResults = 20,
            sourceServerID = drs_source_server_id,
        )
        
        snap_ids = None
        for snap in snapshots['items']:
            # print('snapshot id: {}'.format(snap['snapshotID']))
            # print('ebsSnapshots: {}'.format(len(snap['ebsSnapshots'])))
            snap_count = len(snap['ebsSnapshots'])
            if (snap_count >= 1):
                snap_ids = snap['ebsSnapshots']
                break
        
        if (snap_ids is None):
            raise Exception('no snapshots found')
        
        # print('DRS source server {} EBS snapshot id(s): {}'.format(
        #     drs_source_server_id,
        #     snap_ids
        # ))
        
        ebs_snapshots = self.ec2_client().describe_snapshots(SnapshotIds=snap_ids)['Snapshots']
        # print('DRS server {} EBS snapshots {}'.format(drs_source_server_name, ebs_snapshots))
        
        if (len(ebs_snapshots) != len(snap_ids)):
            raise Exception('cannot find matching EBS snapshots for DRS source server {}. ebs_snapshots {} snap_ids {}'.format(
                drs_source_server_name,
                ebs_snapshots,
                snap_ids
            ))
        
        ebs_volume_ids = [ebs_snapshot.get('VolumeId') for ebs_snapshot in ebs_snapshots]
        
        return ebs_volume_ids
    
    def get_drs_instance_id_from_id_(self, drs_source_server_id):
        """
        Obtain the id of the replicating EC2 instance associated with a given DRS source server identifier. This method
        queries the DRS, EC2, volumes and snapshot API to find the instance id, which is typically used at a later step to
        kickoff malware scan analysis. Roughly, it does:
        
        1. Query the DRS API to validate that the source server is healthy, and replicating continuouslly to AWS.
        2. Query again the DRS API to get details of a recent EBS snapshot performed by DRS for this source server.
        3. Checks that the DRS EBS snapshot is associated to a replicating EBS volume, and gets the id of it.
        4. Describe the replicating EBS volume to find the instance it is attached to. This is the replicating EC2 instance.
        
        Recall that currently, the only way to kickoff malware scan is pointing GuardDuty to a live EC2 instance, i.e., we
        don't have a public API to perform the analysis on an EB2 snapshot or DRS source server, so we go the long way and
        scan the replicating EC2 instance.
        
        Because the replicating EC2 instance can be associated to other DRS source servers, on- or off-prem, the related
        GuardDuty finding may or may not be associated to our DRS source server. This means that this solution must provide
        the mechanisms to let the end-user identify the correct outcome. Please bear this in mind to understand the annotations
        performed by this function and the rest of the steps performed everywhere else.
        """
        
        response = self.drs_client().describe_source_servers(
            filters = {
                'sourceServerIDs': [
                    drs_source_server_id,
                ],
            },
            maxResults = 10
        )

        # print(json.dumps(response))
        source_server = response['items'][0]
        
        server_name = source_server['tags']['Name']                                             # e.g. w7x64
        server_id = source_server['sourceServerID']                                             # s-369f64697e68f21bf
        server_arn = source_server['arn']
        server_disk_count = len(source_server['sourceProperties']['disks'])                     # attached disk count
        server_hostname = source_server['sourceProperties']['identificationHints']['hostname']  # w7x64
        server_fqdn = source_server['sourceProperties']['identificationHints']['fqdn']          # w7x64
        server_replication_state = source_server['dataReplicationInfo']['dataReplicationState'] # STALLED
        
        # print('source server: {}'.format(server_name))
        # print('id: {}'.format(server_id))
        # print('arn: {}'.format(server_arn))
        # print('disks: {}'.format(server_disk_count))
        # print('hostname: {}'.format(server_hostname))
        # print('fqdn: {}'.format(server_fqdn))
        # print('replication state: {}'.format(server_replication_state))
        
        if (server_replication_state != 'CONTINUOUS'):
            # raise Exception('error: cannot scan source server {}: replication stalled, no replicating EC2 instance to scan'.format(
            #     server_name
            # ))
            
            print(('warning: DRS replication state is {} for source server {}. In order kickoff malware scan, we need the ' +
                   'replicating EC2 instance id. If replication state is not {}, this instance may or may not exist. Please ' +
                   'fix the DRS replication before attempting malware scan of this server.').format(
                server_replication_state,
                server_name,
                'CONTINUOUS'
            ))
        
        snapshots = self.drs_client().describe_recovery_snapshots(
            maxResults = 20,
            order='DESC',
            sourceServerID=source_server['sourceServerID']
        )
        # print(json.dumps(snapshots))
        
        snap_found = False
        for snap in snapshots['items']:
            # print('snapshot id: {}'.format(snap['snapshotID']))
            # print('ebsSnapshots: {}'.format(len(snap['ebsSnapshots'])))
            snap_count = len(snap['ebsSnapshots'])
            if (snap_count >= 1):
                snap_id = snap['ebsSnapshots'][0]
                snap_found = True
                break
        
        if (snap_found == False):
            raise Exception('no snapshots found')
        
        ebs_snapshots = self.ec2_client().describe_snapshots(
            SnapshotIds = [
                snap_id,
            ],
        )
        
        ebs_snap_found = False
        for ebs_snap in ebs_snapshots['Snapshots']:
            # print('EBS snapshot id: {}'.format(ebs_snap['SnapshotId']))
        
            if (self.ebs_snap_with_drs_tags(ebs_snap) == False):
                continue
        
            if (ebs_snap['SnapshotId'] == snap_id):
                ebs_snap_found = True
                break
            
        if (ebs_snap_found == False):
            raise Exception('cannot find EBS the snapshot')
        
        volume_description = self.ec2_client().describe_volumes(
            VolumeIds = [
                ebs_snap['VolumeId'],
            ]
        )
        ebs_volume = volume_description['Volumes'][0]
        
        if ('Attachments' not in ebs_volume
            or len(ebs_volume['Attachments']) != 1
            or ebs_volume['Attachments'][0]['State'] != 'attached'):
            raise Exception(('replicating EBS volume of source server {} is not attached to a DRS instance. Please, get the ' +
                             'replication stream to a HEALTHY state before attempting malware scan on this server.').format(
                server_name
            ))
        
        if (self.ebs_volume_with_drs_tags(ebs_volume) == False):
            raise Exception('cannot find the EBS volume')
        
        # print('DRS instance id: {}'.format(ebs_volume['Attachments'][0]['InstanceId']))
        return ebs_volume['Attachments'][0]['InstanceId']
    
    def ebs_snap_with_drs_tags(self, ebs_snap):
        """
        This method receives an object describing an EBS snapshot and validates that the snapshot is tagged appropriately.
        It checks for presence of both Name and AWSElasticDisasterRecoveryManaged tags, and corresponding values. These are
        used to sanity check the snapshots returned by the DRS API, the results of describe_snapshots() when it is applied to
        snapshot objects returned by the DRS API.
        """
        
        match = False
        match_key = False
        match_managed = False
        
        for tag in ebs_snap['Tags']:
            # Check Name and value.
            if (tag['Key'] == 'Name'):
                if (tag['Value'] == 'AWS Elastic Disaster Recovery Snapshot'):
                    match_key = True;
                else:
                    break
            
            # Validate AWSElasticDisasterRecoveryManaged and value.
            if (tag['Key'] == 'AWSElasticDisasterRecoveryManaged'):
                if (tag['Value'] == 'drs.amazonaws.com'):
                    match_managed = True;
                else:
                    break
        
        # Make sure both tags and values ares present.
        if (match_key and match_managed):
            match = True
        
        return match
    
    def ebs_volume_with_drs_tags(self, ebs_vol):
        """
        This method receives an object describing an EBS volume and validates that it is tagged appropriately. It checks for 
        presence of both Name and AWSElasticDisasterRecoveryManaged tags, and corresponding values. These are used to sanity check
        the EBS volumes associated with snapshots returned by the DRS API.
        """
        
        match = False
        match_name = False
        match_managed = False
        
        for tag in ebs_vol['Tags']:
            # Check for Name and value.
            if (tag['Key'] == 'Name'):
                if (tag['Value'] == 'AWS Elastic Disaster Recovery Replication Volume'):
                    match_name = True;
                else:
                    break
            
            # Validate AWSElasticDisasterRecoveryManaged and value.
            if (tag['Key'] == 'AWSElasticDisasterRecoveryManaged'):
                if (tag['Value'] == 'drs.amazonaws.com'):
                    match_managed = True;
                else:
                    break
        
        if (match_name and match_managed):
            match = True
        
        return match
    
    def set_guardduty_tags(self, instance_id, ebs_volumes):
        """
        TBD
        """
        
        guardduty_excluded_true = {
            'Tags': [{
                'Key': 'GuardDutyExcluded',
                'Value': 'true',
            }],
            'Resources': [],
        }
        
        guardduty_excluded_false = {
            'Tags': [{
                'Key': 'GuardDutyExcluded',
                'Value': 'false',
            }],
            'Resources': [],
        }
        
        guardduty_excluded_all = {
            'Tags': [{
                'Key': 'GuardDutyExcluded',
            }],
            'Resources': [],
        }
        
        description = self.ec2_client().describe_instance_attribute(
            InstanceId = instance_id,
            Attribute = 'blockDeviceMapping',
        )
        
        # print('debug: instance id {} EBS mapping {}'.format(
        #     instance_id,
        #     description,
        # ))
        
        for ebs_mapping in description['BlockDeviceMappings']:
            volume_id = ebs_mapping['Ebs']['VolumeId']
            volume_status = ebs_mapping['Ebs']['Status']
            
            if (volume_status != 'attached'):
                raise Exception('cannot set GuardDuty exclusion tags: EBS volume {} instance {} attachment status {}'.format(
                    volume_id,
                    instance_id,
                    volume_status,
                ))
            
            # Include the volume in the list of tags to be removed.
            guardduty_excluded_all['Resources'].append(volume_id)
            
            # Now, conditionally include the volume in the list of tags to be set.
            if (volume_id in ebs_volumes):
                guardduty_excluded_false['Resources'].append(volume_id)
            else:
                guardduty_excluded_true['Resources'].append(volume_id)
            
        if (len(guardduty_excluded_false['Resources']) != len(ebs_volumes)):
            raise Exception('cannot set GuardDuty exclusion tags: invalid instance id {} volume count'.format(
                instance_id,
            ))
        
        ct_result = self.ec2_client().delete_tags(
            Resources = guardduty_excluded_all['Resources'],
            Tags = guardduty_excluded_all['Tags'],
        )
        
        if (ct_result['ResponseMetadata']['HTTPStatusCode'] != 200):
            raise Exception('cannot remove GuardDuty exclusion tags: delete_tags returned HTTPStatusCode {}'.format(
                ct_result['HTTPStatusCode'],
            ))
        
        ct_result = self.ec2_client().create_tags(
            Resources = guardduty_excluded_true['Resources'],
            Tags = guardduty_excluded_true['Tags'],
        )
        
        if (ct_result['ResponseMetadata']['HTTPStatusCode'] != 200):
            raise Exception('cannot set GuardDuty exclusion tags: create_tags returned HTTPStatusCode {}'.format(
                ct_result['HTTPStatusCode'],
            ))
        
        # ct_result = self.ec2_client().create_tags(
        #     Resources = guardduty_excluded_false['Resources'],
        #     Tags = guardduty_excluded_false['Tags'],
        # )
        # 
        # if (ct_result['ResponseMetadata']['HTTPStatusCode'] != 200):
        #     raise Exception('cannot set GuardDuty exclusion tags: create_tags returned HTTPStatusCode {}'.format(
        #         ct_result['HTTPStatusCode'],
        #     ))
    
    def get_instance_arn(self, name):
        """
        Assemble the ARN of an EC2 instsance from a given instance name. For example:
        
        o When name is an ARN (i.e. it begins with 'arn:') it will be the identity operation.
        o When name is 'qubuntu' it returns arn:aws:ec2:us-east-1:607162100326:instance/i-f8416e0d06fa9803e.
        """
        
        instance_arn = name
        if (not re.match('^arn:', name)):
            ec2_instance_id = name
            
            caller_identity = self.sts_client().get_caller_identity()
            boto3_session = boto3.session.Session()
            
            instance_arn = 'arn:aws:ec2:{}:{}:instance/{}'.format(
                boto3_session.region_name,
                caller_identity['Account'],
                ec2_instance_id
            )
        
        return instance_arn
    
    def ddb_client(self):
        if (self.ddb_client_ is None):
            self.ddb_client_ = boto3.client('dynamodb')
        
        return self.ddb_client_
    
    def drs_client(self):
        if (self.drs_client_ is None):
            self.drs_client_ = boto3.client('drs')
        
        return self.drs_client_
    
    def ec2_client(self):
        if (self.ec2_client_ is None):
            self.ec2_client_ = boto3.client('ec2')
        
        return self.ec2_client_
    
    def sqs_client(self):
        if (self.sqs_client_ is None):
            self.sqs_client_ = boto3.client('sqs')
        
        return self.sqs_client_
    
    def sts_client(self):
        if (self.sts_client_ is None):
            self.sts_client_ = boto3.client('sts')
        
        return self.sts_client_
