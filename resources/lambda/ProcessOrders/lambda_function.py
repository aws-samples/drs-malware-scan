import re
import os

import json
import time
import boto3
import random

from DRSHelper import DRSHelper
from DRSHelper import ExDRSInstanceBusy

# Initialize DRS helper.
drs_helper = DRSHelper()

tracking_threshold = 7200
# tracking_threshold = 60

def lambda_handler(events, context):
    """
    TBD
    """
    
    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))
    
    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))
    
    result = {
        'batchItemFailures': [],
    }
    
    try:
        scan_order = read_scan_order(events)
        # print_scan_order(scan_order)
        populate_scan_order(scan_order)
        execute_scan_order(scan_order)
        delete_scan_order(scan_order)
    except ExDRSInstanceBusy:
        result['batchItemFailures'].append({
            'itemIdentifier': scan_order['sqs_message_id'],
        })
    except Exception as ex:
        raise ex
    
    return result

def read_scan_order(events):
    """
    TBD
    """
    
    # Initialize.
    scan_order = {}
    
    if (len(events['Records']) != 1):
        raise Exception('read_scan_order() received an invalid records count of {}'.format(
            len(events['Records']),
        ))
    
    scan_order['sqs_message_id'] = events['Records'][0]['messageId']
    scan_order['sqs_receipt_handle'] = events['Records'][0]['receiptHandle']
    
    message_body = json.loads(events['Records'][0]['body'])
    scan_order['source_server_id'] = message_body['source_server_id']
    scan_order['source_server_name'] = message_body['source_server_name']

    # Record the message id to remove the record from SQS.
    scan_order['sqs_message_id'] = events['Records'][0]['messageId']
        
    return scan_order

def print_scan_order(scan_order):
    text = ''

    text += 'source_server_id {}'.format(
        scan_order['source_server_id']
    )
    
    text += ' source_server_name {}'.format(
        scan_order['source_server_name']
    )
    
    text += ' sqs_receipt_handle {}'.format(
        scan_order['sqs_receipt_handle']
    )
    
    print('debug: scan_order: {}'.format(text))

def populate_scan_order(scan_order):
    """
    TBD
    """
    
    server_id = scan_order['source_server_id']
    server_name = scan_order['source_server_name']
    
    ebs_volumes = drs_helper.get_replicating_ebs_volume_ids(server_name, server_id)
    print('debug: DRS source server {} associated to EBS volumes {}'.format(server_name, ebs_volumes))
    
    drs_instance_id = drs_helper.get_drs_instance_id(server_id)
    print('debug: DRS source server {} associated to DRS instance id {}'.format(server_name, drs_instance_id))
    
    drs_instance_arn = drs_helper.get_instance_arn(drs_instance_id)
    print('debug: DRS source server {} associated to DRS instance arn {}'.format(server_name, drs_instance_arn))
    
    scan_order['ebs_volumes'] = ebs_volumes
    scan_order['drs_instance_id'] = drs_instance_id
    scan_order['drs_instance_arn'] = drs_instance_arn

def execute_scan_order(scan_order):
    """
    TBD
    """
    
    # Make sure the instance is ready for malware scan.
    check_instance_annotations(scan_order)

    # Tag the EBS volumes of the DRS instance appropriately.
    drs_helper.set_guardduty_tags(scan_order['drs_instance_id'], scan_order['ebs_volumes'])

    # Annotate the context of the ongoing scan operation.
    init_instance_annotations(scan_order)

    # Submit the malware scan command.
    queue_scan_command(scan_order)

def delete_scan_order(scan_order):
    status = drs_helper.sqs_client().delete_message(
        QueueUrl = os.environ.get('SQS_SCAN_ORDERS_URL'),
        ReceiptHandle = scan_order['sqs_receipt_handle'],
    )
    
    print('debug: delete_scan_order: sqs.delete_message(): {}'.format(str(status)))

def check_instance_annotations(scan_order):
    result = drs_helper.ddb_client().get_item(
        TableName = os.environ.get('DDB_DRS_INSTANCE_ANNOTATIONS'),
        Key = {
            'drs_instance_id': {
                'S': scan_order['drs_instance_id'],
            }
        },
    )
    
    if ('Item' not in result):
        return
    
    scan_step = result['Item']['scan_step']['S']
    scan_time_start = int(result['Item']['scan_time_start']['N'])
    
    if (scan_step == 'completed'):
        return
    
    if (scan_time_start <= (time.time() - tracking_threshold)):
        return
    
    raise ExDRSInstanceBusy('DRS instance id {} maked busy, possibly being scanned'.format(
        scan_order['drs_instance_id']
    ))

def init_instance_annotations(scan_order):
    try:
        result = drs_helper.ddb_client().update_item(
            TableName = os.environ.get('DDB_DRS_INSTANCE_ANNOTATIONS'),
            ExpressionAttributeNames = {
                '#SS': 'scan_step',
                '#STS': 'scan_time_start',
                '#STE': 'scan_time_end',
                '#SID': 'scan_id',
            },
            ExpressionAttributeValues = {
                ':ss_init': {
                    'S': 'init',
                },
                ':ss_completed': {
                    'S': 'completed',
                },
                ':st_now': {
                    'N': str(int(time.time())),
                },
                ':st_threshold': {
                    'N': str(int(time.time() - tracking_threshold)),
                },
                ':st_zero': {
                    'N': '0',
                },
                ':ss_na': {
                    'S': 'n/a',
                },
            },
            Key = {
                'drs_instance_id': {
                    'S': scan_order['drs_instance_id'],
                }, 
            },
            ConditionExpression = '(attribute_not_exists(drs_instance_id) OR (#SS = :ss_completed)) OR ' +
                                  '(attribute_exists(drs_instance_id) AND (#STS <= :st_threshold))',
            UpdateExpression = 'SET #SS = :ss_init, #STS = :st_now, #STE = :st_zero, #SID = :ss_na',
            ReturnValues = 'ALL_NEW',
        )
    except drs_helper.ddb_client().exceptions.ConditionalCheckFailedException:
        # XXX
        raise Exception('cannot annotate instance id {} tracking to init: conditional check failed'.format(
            scan_order['drs_instance_id'],
        ))

def queue_scan_command(scan_order):
    status = drs_helper.sqs_client().send_message(
        QueueUrl = os.environ.get('SQS_SCAN_COMMANDS_URL'),
        MessageBody = json.dumps({
            'ebs_volumes': scan_order['ebs_volumes'],
            'drs_instance_id': scan_order['drs_instance_id'],
            'drs_instance_arn': scan_order['drs_instance_arn'],
            'source_server_id': scan_order['source_server_id'],
            'source_server_name': scan_order['source_server_name'],
        }),
        MessageDeduplicationId = str(random.random()),
        MessageGroupId = '1',
    )
    
    print('debug: queue_scan_command: sqs.send_message(): {}'.format(str(status)))

if (__name__ == "__main__"):
    with open("/dev/stdin") as file:
        events = json.load(file)
    lambda_handler(events, '')
