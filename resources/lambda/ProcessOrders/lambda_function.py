import re
import os

import json
import time
import boto3
import random

from DRSHelper import DRSHelper
from DRSHelper import ExDRSInstanceBusy

# Initialize DRS helper.
drs_helper = DRSHelper()

tracking_threshold = 7200
# tracking_threshold = 60

def lambda_handler(events, context):
    """
    The ProcessOrders function prepares malware scan orders for execution. The function is executed by a lambda trigger
    connected to an SQS FIFO queue containing malware scan orders submitted by the SubmitOrders function. Both components,
    i.e. queue and lambda function, are critical to control concurrency and avoid racing over the same DRS replicating 
    instance as explained below.
    
    ProcessOrders receives input through an SQS FIFO queue controlled by SQS_SCAN_ORDERS_URL. The FIFO contains orders 
    submitted through the SubmitOrders lambda function. ProcessOrders dequeues one order at a time, enriching the operation
    with additional information to invoke GuardDuty Malware Scan later down the pipeline.
    
    Currently, the GuardDuty malware scan APIs do not allow to identify the outcome of a scan operation individually, at
    the level of an EBS volume. Now consider the many-to-one relation between DRS source servers and the replicating DRS
    instance to which they are connected to: GuardDuty malware scan only provides a single outcome for the entire scan ops,
    so it is impossible to tell which DRS source server is infected in such escenario.
    
    To workaround this, ProcessOrder prepares scan operations individually for each DRS source server. The function tags
    the EBS volumes of the associated replicating instance in order to control which volumes to exclude from scanning, so
    that only the volumes from the intended DRS source server get analyzed for malware. The function sets GuardDutyExcluded
    to all of the EBS volumes that are not associated to the DRS source server.
    
    After tagging the EBS volumes, ProcessOrders submits a malware scan command downstream through the FIFO queue pointed by
    SQS_SCAN_COMMANDS_URL. The command queued into SQS contains all of the necessary information to invoke GuardDuty malware
    scan later down the pipeline, at a maximum rate of one command per second in order to prevent API throttling.
    
    Now, consider what happens after the volumes of the replicating EC2 instance are tagged with GuardDutyExcluded. A race
    condition could happen if any other concurrent execution of ProcessOrders attempts to tag the EBS volumes connected to 
    the same DRS instance while the original malware scan operation is in flight.

    To prevent this race condition, the messages in the SQS_SCAN_ORDERS_URL FIFO queue are grouped using the id of the DRS 
    replicating instance using the SQS attribute MessageGroupId, and processed one at a time (i.e. the SQS batch size is 
    unitary). These enable to control concurrency and avoid tagging the EBS volumes of the DRS replicating instance when 
    there's an ongoing malware scan operation executed on behalf of that same EC2 VM. When the ProcessOrders lambda function
    is triggered by the source FIFO, it checks a DynamoDB table containing annotations to track malware scan operations at 
    the EC2 instance level. This enables ProcessOrders to know whether there's an ongoing malware scan operation mapping to 
    the same replicating instance, thus preventing the race condition.
    
    Also, grouping scan orders inside SQS_SCAN_ORDERS_URL using the id of the replicating DRS instance enables for concurrent
    malware scan operations over differente DRS instances. This allow us analyze DRS source servers faster, at a rate that is
    compatible with the existing capabilities of the GuardDuty API.
    """
    
    # print('events: {}'.format(str(events)))
    # print('context: {}'.format(str(context)))
    
    # print('boto3 version: {}'.format(boto3.__version__))
    # print('botocore version: {}'.format(botocore.__version__))
    
    # We are about to process a malware scan order. If this operation maps to a replicating DRS instance with a malware scan 
    # operation in flight, we will need to keep the order in the source SQS FIFO queue (pointed by SQS_SCAN_ORDERS_URL). This
    # is donde by using the partial failure feature of SQS, adjunsting batchItemFailures to the id of the SQS message containing
    # the malware scan order.
    result = {
        'batchItemFailures': [],
    }
    
    try:
        # Get a single malware scan order from the SQS FIFO.
        scan_order = read_scan_order(events)
        
        # Uncomment the line below for additional debugging.
        # print_scan_order(scan_order)
        
        # Populate the scan order with the necessary information to invoke GuardDuty malware scan. Essentially, this means 
        # getting the ARN of the replicating DRS instance associated to the given DRS source server, and the list of volumes
        # used by DRS to replicate information.
        populate_scan_order(scan_order)
        
        # If we get to this point, we are ready to submit a malware scan command to analyze the DRS source server. We already
        # know there is now concurrent malware scan operation in flight, and we got all of the relevant information to invoke
        # GuardDuty malware scan. Also, execute_scan_order() will track in-flight malware scan operations at the level of the
        # replicating DRS instance by performing annotations using a DynamoDB table pointed by DDB_DRS_INSTANCE_ANNOTATIONS.
        execute_scan_order(scan_order)
        
        # Sucess. Delete the message from the source SQS FIFO queue.
        delete_scan_order(scan_order)
    except ExDRSInstanceBusy:
        # We got here because the replicating instance associated to the DRS source server is busy, i.e., an different malware
        # scan operations is currently in-flight. Just mark the SQS message for failure and let the visibility timeout retry the
        # operation later.
        result['batchItemFailures'].append({
            'itemIdentifier': scan_order['sqs_message_id'],
        })
        # Unknown error. This should never happen.
    except Exception as ex:
        raise ex
    
    return result

def read_scan_order(events):
    """
    Get a single malware scan order from the SQS FIFO. This function parses the SQS event message to extract a malware 
    scan order queued by the SubmitOrders lambda. At this stage, the scan order contains end-user information such as
    the name and id of the DRS source server to perform malware scan. The function parses these attributes and builds a
    dict modeling the end-user scan order.
    """
    
    # Initialize.
    scan_order = {}
    
    # Sanity check. As explained elsewhere, ProcessOrder does one scan order message at a time.
    if (len(events['Records']) != 1):
        raise Exception('read_scan_order() received an invalid records count of {}'.format(
            len(events['Records']),
        ))
    
    # These are needed in case we detect a concurrent, in-flight malware scan operation and need to retry this order at
    # a later stage, on order to prevent the race condition explained in the introduction of this file. Also to remove 
    # the record from SQS in case of success as well.
    scan_order['sqs_message_id'] = events['Records'][0]['messageId']
    scan_order['sqs_receipt_handle'] = events['Records'][0]['receiptHandle']
    
    # Extract end-user attributes: id and name of the DRS source server to which we want to perform malware scan to.
    message_body = json.loads(events['Records'][0]['body'])
    scan_order['source_server_id'] = message_body['source_server_id']
    scan_order['source_server_name'] = message_body['source_server_name']
    
    # Success.
    return scan_order

def print_scan_order(scan_order):
    text = ''

    text += 'source_server_id {}'.format(
        scan_order['source_server_id']
    )
    
    text += ' source_server_name {}'.format(
        scan_order['source_server_name']
    )
    
    text += ' sqs_receipt_handle {}'.format(
        scan_order['sqs_receipt_handle']
    )
    
    print('debug: scan_order: {}'.format(text))

def populate_scan_order(scan_order):
    """
    Enrich a scan_order object with additional information to invoke GuardDuty malware scan: ids of the replicating EBS
    volume(s) and instance. This is done by querying the DRS API inside the DRSHelper module.
    """
    
    server_id = scan_order['source_server_id']
    server_name = scan_order['source_server_name']
    
    ebs_volumes = drs_helper.get_replicating_ebs_volume_ids(server_name, server_id)
    print('debug: DRS source server {} associated to EBS volumes {}'.format(server_name, ebs_volumes))
    
    drs_instance_id = drs_helper.get_drs_instance_id(server_id)
    print('debug: DRS source server {} associated to DRS instance id {}'.format(server_name, drs_instance_id))
    
    drs_instance_arn = drs_helper.get_instance_arn(drs_instance_id)
    print('debug: DRS source server {} associated to DRS instance arn {}'.format(server_name, drs_instance_arn))
    
    scan_order['ebs_volumes'] = ebs_volumes
    scan_order['drs_instance_id'] = drs_instance_id
    scan_order['drs_instance_arn'] = drs_instance_arn

def execute_scan_order(scan_order):
    """
    Submit an order to perform a malware scan operation on a given DRS source server. This means:
    
    1. Making sure that no other malware scan operations are concurrent for the given DRS replicating instance.
    
    2. Tagging the EBS volumes of the replicating instance appropriately, in order to scan only the EBS volumes related to
       the DRS source server to which we want to perform the scan. This is done by setting GuardDutyExcluded tags.
    
    3. Prevent a race condition. Annotate the context of the ongoing scan operation, so that ProcessOrder can prevent 
       executing malware scan orders mapped to the same DRS replicating instance concurrently, while the original operation
       is still in flight.
    
    4. Finally, prepare a malware scan command and submit it down the execution pipeline to perform the malware scan. 
    """
    
    # Make sure the instance is ready for malware scan.
    check_instance_annotations(scan_order)

    # Tag the EBS volumes of the DRS instance appropriately.
    drs_helper.set_guardduty_tags(scan_order['drs_instance_id'], scan_order['ebs_volumes'])

    # Annotate the context of the ongoing scan operation.
    init_instance_annotations(scan_order)

    # Submit the malware scan command.
    queue_scan_command(scan_order)

def delete_scan_order(scan_order):
    """
    Remove a scan order message from the source SQS FIFO.
    """
    
    status = drs_helper.sqs_client().delete_message(
        QueueUrl = os.environ.get('SQS_SCAN_ORDERS_URL'),
        ReceiptHandle = scan_order['sqs_receipt_handle'],
    )
    
    print('debug: delete_scan_order: sqs.delete_message(): {}'.format(str(status)))

def check_instance_annotations(scan_order):
    """
    Check the instance annotations of the replicating DRS instance to which scan_order points to. 
    
    Before moving forward with the malware scan operation related to the scan_order object, we need to make sure that the
    replicating DRS instance is being concurrently scanned, nor there is a different malware scan operation in-flight. As
    explained above, this check is needed to prevent racing over the same replicating instance.
    
    This functions just returns when there are no concurrent or in-flight malware scan operations tracked by the DynamoDB
    annotations table. Complementarily, when we found that the replicating instance is busy, it throws an ExDRSInstanceBusy
    exception.
    """
    
    # Get the instance annotations by querying the DynamoDB table pointed by the environment (DDB_DRS_INSTANCE_ANNOTATIONS).
    result = drs_helper.ddb_client().get_item(
        TableName = os.environ.get('DDB_DRS_INSTANCE_ANNOTATIONS'),
        Key = {
            'drs_instance_id': {
                'S': scan_order['drs_instance_id'],
            }
        },
    )
    
    # No annotations found. This happens e.g. when a new DRS replicating instance is running, and a malware scan operations
    # is submitted to scan a DRS source server replicated by this VM.
    if ('Item' not in result):
        return
    
    # Extract relevant attributes: scan step and timestamp of the previous operation.
    scan_step = result['Item']['scan_step']['S']
    scan_time_start = int(result['Item']['scan_time_start']['N'])
    
    # Replicating instance is ready when not currently running an ongoing malware scan operation (i.e. marked as completed).
    if (scan_step == 'completed'):
        return
    
    # Replicating instance is not marked as completed, but a lot of time has passed since the last annotation was made. In 
    # order to prevent stalling the solution, we just assume a lost message and move forward with the current scan order.
    if (scan_time_start <= (time.time() - tracking_threshold)):
        return
    
    # We get here when the instance is not marked as compleded, so there is an ongoing operation in flight. Also the operation
    # is recent, in the sense that it within the maximum time limit configured by the tracking_threshold parameter.
    raise ExDRSInstanceBusy('DRS instance id {} maked busy, possibly being scanned'.format(
        scan_order['drs_instance_id']
    ))

def init_instance_annotations(scan_order):
    """
    Initialize instance annotations for a given scan_order enriched with the id of the replicating DRS instance. This
    function queries the DynamoDB table pointed by DDB_DRS_INSTANCE_ANNOTATIONS using the EC2 id of the instance. 
    
    The function asserts that no concurrent or in-flight malware scan operations exist, i.e., it must be invoked then the
    related check_instance_annotations() function signals that the replicating instance is free to scan. Also a previous 
    annotations record may or may not exist. 

    1. When no annotations pre-exist, it creates a new annotations record with the given replicating instance id.
    
    2. Otherwise, it checks that the pre-existing annotations track the instance with scan step set to 'completed' and
       updates the annotations record appropriately.
    
    3. When the instance tracking record is marked as 'completed', but a considerable time passed, it assumes that the
       record is stale and also updates annotation to move forward with the scan order and prevent stalls.
    
    4. When neither of the conditions are true, it means there is an ongoing scan operation in flight. In that case, it
       assumes that the assertion failed and raises a exception, preventing a potential race condition and logging an
       error message to let the user investigate.
    """
    
    try:
        result = drs_helper.ddb_client().update_item(
            TableName = os.environ.get('DDB_DRS_INSTANCE_ANNOTATIONS'),
            ExpressionAttributeNames = {
                '#SS': 'scan_step',
                '#STS': 'scan_time_start',
                '#STE': 'scan_time_end',
                '#SID': 'scan_id',
            },
            ExpressionAttributeValues = {
                ':ss_init': {
                    'S': 'init',
                },
                ':ss_completed': {
                    'S': 'completed',
                },
                ':st_now': {
                    'N': str(int(time.time())),
                },
                ':st_threshold': {
                    'N': str(int(time.time() - tracking_threshold)),
                },
                ':st_zero': {
                    'N': '0',
                },
                ':ss_na': {
                    'S': 'n/a',
                },
            },
            Key = {
                'drs_instance_id': {
                    'S': scan_order['drs_instance_id'],
                }, 
            },
            ConditionExpression = '(attribute_not_exists(drs_instance_id) OR (#SS = :ss_completed)) OR ' +
                                  '(attribute_exists(drs_instance_id) AND (#STS <= :st_threshold))',
            UpdateExpression = 'SET #SS = :ss_init, #STS = :st_now, #STE = :st_zero, #SID = :ss_na',
            ReturnValues = 'ALL_NEW',
        )
    except drs_helper.ddb_client().exceptions.ConditionalCheckFailedException:
        # XXX
        raise Exception('cannot annotate instance id {} tracking to init: conditional check failed'.format(
            scan_order['drs_instance_id'],
        ))

def queue_scan_command(scan_order):
    """
    Queue a scan command containing all of the necessary information to invoke GuardDuty malware scan.
    """
    
    status = drs_helper.sqs_client().send_message(
        QueueUrl = os.environ.get('SQS_SCAN_COMMANDS_URL'),
        MessageBody = json.dumps({
            'ebs_volumes': scan_order['ebs_volumes'],
            'drs_instance_id': scan_order['drs_instance_id'],
            'drs_instance_arn': scan_order['drs_instance_arn'],
            'source_server_id': scan_order['source_server_id'],
            'source_server_name': scan_order['source_server_name'],
        }),
        MessageDeduplicationId = str(random.random()),
        MessageGroupId = '1',
    )
    
    print('debug: queue_scan_command: sqs.send_message(): {}'.format(str(status)))

if (__name__ == "__main__"):
    with open("/dev/stdin") as file:
        events = json.load(file)
    lambda_handler(events, '')
