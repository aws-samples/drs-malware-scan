import { Stack, StackProps, RemovalPolicy, Duration } from "aws-cdk-lib";
import { Construct } from "constructs";
import {
  Function,
  Runtime,
  Code,
  LayerVersion,
  EventSourceMapping,
  Architecture
} from "aws-cdk-lib/aws-lambda";
import {
  Table,
  AttributeType,
  BillingMode,
  ProjectionType,
} from "aws-cdk-lib/aws-dynamodb";
import {
  Role,
  ServicePrincipal,
  ManagedPolicy,
  PolicyStatement,
} from "aws-cdk-lib/aws-iam";
import {
  Rule,
  Schedule,
  RuleTargetInput,
  EventPattern,
} from "aws-cdk-lib/aws-events";
import {
  Queue,
  FifoThroughputLimit,
  DeduplicationScope,
} from "aws-cdk-lib/aws-sqs";
import { LambdaDestination } from "aws-cdk-lib/aws-logs-destinations";
import {
  FilterPattern,
  LogGroup,
  SubscriptionFilter,
} from "aws-cdk-lib/aws-logs";
import { LambdaFunction } from "aws-cdk-lib/aws-events-targets";
import * as path from "path";

export class DrsMalwareScanStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // Amazon DynamoDB Tables

    //  DynamoDB Table for Source Server to be scanned
    const sourceServersTable = new Table(this, "SourceServersDDBTable", {
      partitionKey: { name: "server_name", type: AttributeType.STRING },
      removalPolicy: RemovalPolicy.DESTROY,
    });

    //  DynamoDB Table for DRS Instance Annotations to be scanned
    const drsInstanceAnnotationsTable = new Table(
      this,
      "DRSInstanceAnnotationsDDBTable",
      {
        partitionKey: { name: "drs_instance_id", type: AttributeType.STRING },
        removalPolicy: RemovalPolicy.DESTROY,
      },
    );

    //  DynamoDB Table for DRS Volume Annotations to be scanned
    const drsVolumeAnnotationsTable = new Table(
      this,
      "DRSVolumeAnnotationsDDBTable",
      {
        partitionKey: { name: "scan_id", type: AttributeType.STRING },
        sortKey: { name: "ebs_volume_id", type: AttributeType.STRING },
        removalPolicy: RemovalPolicy.DESTROY,
      },
    );

    drsVolumeAnnotationsTable.addGlobalSecondaryIndex({
      indexName: "reverseIndex",
      partitionKey: { name: "ebs_volume_id", type: AttributeType.STRING },
      sortKey: { name: "scan_id", type: AttributeType.STRING },
      projectionType: ProjectionType.ALL,
    });

    // Amazon SQS

    // create SQS FIFO queue for scanning Orders
    const scanOrdersQueue = new Queue(this, "ScanOrders.fifo", {
      fifo: true,
      visibilityTimeout: Duration.seconds(120),
      retentionPeriod: Duration.days(4),
      fifoThroughputLimit: FifoThroughputLimit.PER_MESSAGE_GROUP_ID,
      deduplicationScope: DeduplicationScope.MESSAGE_GROUP,
    });

    // create SQS FIFO queue for scanning Commands
    const scanCommandsQueue = new Queue(this, "ScanCommands.fifo", {
      fifo: true,
      visibilityTimeout: Duration.seconds(120),
      retentionPeriod: Duration.days(4),
      fifoThroughputLimit: FifoThroughputLimit.PER_MESSAGE_GROUP_ID,
      deduplicationScope: DeduplicationScope.MESSAGE_GROUP,
    });

    // Amazon Lambda Layer

    // Create Lambda Layer
    const drsHelperLayer = new LayerVersion(this, "DRSHelperLayer", {
      compatibleRuntimes: [Runtime.PYTHON_3_11],
      compatibleArchitectures: [Architecture.X86_64, Architecture.ARM_64],
      code: Code.fromAsset(
        path.join(__dirname, "/../resources/lambda/layers/"),
      ),
    });

    // Security to invoke Lambda Layer

    // Create a Policy Statement for DRSHelper Layer
    const drsHelperPolicy = new PolicyStatement({
      actions: [
        "drs:DescribeSourceServers",
        "drs:DescribeRecoverySnapshots",
        "sts:GetCallerIdentity",
        "ec2:DeleteTags",
        "ec2:CreateTags",
        "ec2:DescribeInstanceAttribute",
        "ec2:DescribeVolumes",
        "ec2:DescribeSnapshots",
      ],
      resources: ["*"],
    });

    // Process Orders module

    // Lambda Role for processOrders
    const processOrdersLambdaIamRole = new Role(this, "ProcessOrdersRole", {
      assumedBy: new ServicePrincipal("lambda.amazonaws.com"),
      managedPolicies: [
        ManagedPolicy.fromAwsManagedPolicyName(
          "service-role/AWSLambdaSQSQueueExecutionRole",
        ),
        ManagedPolicy.fromAwsManagedPolicyName(
          "service-role/AWSLambdaBasicExecutionRole",
        ),
      ],
    });

    processOrdersLambdaIamRole.addToPolicy(drsHelperPolicy);

    processOrdersLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["dynamodb:UpdateItem", "dynamodb:GetItem"],
        resources: [drsInstanceAnnotationsTable.tableArn],
      }),
    );

    processOrdersLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["sqs:DeleteMessage"],
        resources: [scanOrdersQueue.queueArn],
      }),
    );

    processOrdersLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["sqs:SendMessage"],
        resources: [scanCommandsQueue.queueArn],
      }),
    );

    // AWS Lambda function

    const processOrdersLambda = new Function(this, "ProcessOrders", {
      runtime: Runtime.PYTHON_3_11,
      memorySize: 128,
      timeout: Duration.seconds(120),
      architecture: Architecture.ARM_64,
      description:
        "Process malware scan orders for on-prem servers replicated with DRS",
      handler: "lambda_function.lambda_handler",
      code: Code.fromAsset(
        path.join(__dirname, "/../resources/lambda/ProcessOrders"),
      ),
      role: processOrdersLambdaIamRole,
      layers: [drsHelperLayer],
      environment: {
        DDB_DRS_INSTANCE_ANNOTATIONS: drsInstanceAnnotationsTable.tableName,
        SQS_SCAN_COMMANDS_URL: scanCommandsQueue.queueUrl,
        SQS_SCAN_ORDERS_URL: scanOrdersQueue.queueUrl,
      },
    });

    const eventSourceMappingProcessOrders = new EventSourceMapping(
      this,
      "ProcessOrdersSQSscanOrdersEvent",
      {
        target: processOrdersLambda,
        batchSize: 1,
        eventSourceArn: scanOrdersQueue.queueArn,
        reportBatchItemFailures: true,
      },
    );

    // Process Commands module

    // Lambda Role for processOrders
    const processCommandsLambdaIamRole = new Role(this, "ProcessCommandsRole", {
      assumedBy: new ServicePrincipal("lambda.amazonaws.com"),
      managedPolicies: [
        ManagedPolicy.fromAwsManagedPolicyName(
          "service-role/AWSLambdaSQSQueueExecutionRole",
        ),
        ManagedPolicy.fromAwsManagedPolicyName(
          "service-role/AWSLambdaBasicExecutionRole",
        ),
      ],
    });

    processCommandsLambdaIamRole.addToPolicy(drsHelperPolicy);

    processCommandsLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["dynamodb:UpdateItem"],
        resources: [drsInstanceAnnotationsTable.tableArn],
      }),
    );

    processCommandsLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["dynamodb:PutItem"],
        resources: [drsVolumeAnnotationsTable.tableArn],
      }),
    );

    processCommandsLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["sqs:DeleteMessage"],
        resources: [scanCommandsQueue.queueArn],
      }),
    );

    processCommandsLambdaIamRole.addToPolicy(
      new PolicyStatement({
        resources: ["*"],
        actions: ["guardduty:StartMalwareScan", "iam:GetRole"],
      }),
    );

    // AWS Lambda function

    const processCommandsLambda = new Function(this, "ProcessCommands", {
      runtime: Runtime.PYTHON_3_11,
      memorySize: 128,
      timeout: Duration.seconds(120),
      architecture: Architecture.ARM_64,
      description:
        "Process malware scan commands for on-prem servers replicated with DRS",
      handler: "lambda_function.lambda_handler",
      code: Code.fromAsset(
        path.join(__dirname, "/../resources/lambda/ProcessCommands"),
      ),
      role: processCommandsLambdaIamRole,
      layers: [drsHelperLayer],
      environment: {
        DDB_DRS_INSTANCE_ANNOTATIONS: drsInstanceAnnotationsTable.tableName,
        DDB_DRS_VOLUME_ANNOTATIONS: drsVolumeAnnotationsTable.tableName,
        SQS_SCAN_COMMANDS_URL: scanCommandsQueue.queueUrl,
      },
    });

    const eventSourceMappingProcessCommands = new EventSourceMapping(
      this,
      "ProcessCommandsSQSscanCommandsEvent",
      {
        target: processCommandsLambda,
        batchSize: 1,
        eventSourceArn: scanCommandsQueue.queueArn,
        reportBatchItemFailures: true, 
      },
    );

    // Submit Orders module

    // Lambda Role for processOrders
    const submitOrdersLambdaIamRole = new Role(this, "SubmitOrdersRole", {
      assumedBy: new ServicePrincipal("lambda.amazonaws.com"),
      managedPolicies: [
        ManagedPolicy.fromAwsManagedPolicyName(
          "service-role/AWSLambdaSQSQueueExecutionRole",
        ),
        ManagedPolicy.fromAwsManagedPolicyName(
          "service-role/AWSLambdaBasicExecutionRole",
        ),
      ],
    });

    submitOrdersLambdaIamRole.addToPolicy(drsHelperPolicy);

    submitOrdersLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["dynamodb:Scan"],
        resources: [sourceServersTable.tableArn],
      }),
    );

    submitOrdersLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["sqs:SendMessage"],
        resources: [scanOrdersQueue.queueArn],
      }),
    );

    // AWS Lambda function

    const submitOrdersLambda = new Function(this, "SubmitOrders", {
      runtime: Runtime.PYTHON_3_11,
      memorySize: 128,
      timeout: Duration.seconds(120),
      architecture: Architecture.ARM_64,
      description:
        "Submit malware scan orders for on-prem servers replicated with DRS",
      handler: "lambda_function.lambda_handler",
      code: Code.fromAsset(
        path.join(__dirname, "/../resources/lambda/SubmitOrders"),
      ),
      role: submitOrdersLambdaIamRole,
      layers: [drsHelperLayer],
      environment: {
        DDB_SOURCE_SERVERS_TABLE: sourceServersTable.tableName,
        SQS_SCAN_ORDERS_URL: scanOrdersQueue.queueUrl,
      },
    });

    // Create EventBridge Scheduler
    const scheduleScanRule = new Rule(this, "ScheduleScanRule", {
      schedule: Schedule.cron({ minute: "0", hour: "4" }),
      description:
        "DRS malware scan configuration stub. Disabled by default to let the administrator setup as needed.",
      targets: [new LambdaFunction(submitOrdersLambda)],
      enabled: false,
    });

    // Security Hub Annotations module

    // Lambda Role for processOrders
    const securityHubAnnotationsLambdaIamRole = new Role(
      this,
      "SecurityHubAnnotationsRole",
      {
        assumedBy: new ServicePrincipal("lambda.amazonaws.com"),
        managedPolicies: [
          ManagedPolicy.fromAwsManagedPolicyName(
            "service-role/AWSLambdaBasicExecutionRole",
          ),
        ],
      },
    );

    securityHubAnnotationsLambdaIamRole.addToPolicy(drsHelperPolicy);

    securityHubAnnotationsLambdaIamRole.addToPolicy(
      new PolicyStatement({
        resources: ["*"],
        actions: ["securityhub:BatchUpdateFindings"],
      }),
    );

    securityHubAnnotationsLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["dynamodb:Query"],
        resources: [drsVolumeAnnotationsTable.tableArn],
      }),
    );

    // AWS Lambda function

    const securityHubAnnotationsLambda = new Function(
      this,
      "SecurityHubAnnotations",
      {
        runtime: Runtime.PYTHON_3_11,
        memorySize: 128,
        timeout: Duration.seconds(120),
        architecture: Architecture.ARM_64,
        description:
          "Generate SecurityHub annotations with the on-prem server name containing malware",
        handler: "lambda_function.lambda_handler",
        code: Code.fromAsset(
          path.join(__dirname, "/../resources/lambda/SecurityHubAnnotations"),
        ),
        role: securityHubAnnotationsLambdaIamRole,
        layers: [drsHelperLayer],
        environment: {
          DDB_DRS_VOLUME_ANNOTATIONS: drsVolumeAnnotationsTable.tableName,
        },
      },
    );

    // Create EvenBridge Rule
    const securityHubAnnotationRule = new Rule(
      this,
      "SecurityHubAnnotationsRule",
      {
        eventPattern: {
          detailType: ["Security Hub Findings - Imported"],
          source: ["aws.securityhub"],
          detail: {
            findings: {
              ProductFields: {
                "aws/guardduty/service/ebsVolumeScanDetails/scanId": [
                  {
                    exists: true,
                  },
                ],
              },
              Note: {
                Text: [
                  {
                    exists: false,
                  },
                ],
              },
            },
          },
        },
        description:
          "Event rule for the DRS malware scan. Used to detect SecurityHub fingings and enrich/annotate as needed.",
        targets: [new LambdaFunction(securityHubAnnotationsLambda)],
      },
    );

    // Subscription Filter module

    // Lambda Role for processOrders
    const subscriptionFilterLambdaIamRole = new Role(
      this,
      "SubscriptionFilterRole",
      {
        assumedBy: new ServicePrincipal("lambda.amazonaws.com"),
        managedPolicies: [
          ManagedPolicy.fromAwsManagedPolicyName(
            "service-role/AWSLambdaSQSQueueExecutionRole",
          ),
          ManagedPolicy.fromAwsManagedPolicyName(
            "service-role/AWSLambdaBasicExecutionRole",
          ),
        ],
      },
    );

    subscriptionFilterLambdaIamRole.addToPolicy(drsHelperPolicy);

    subscriptionFilterLambdaIamRole.addToPolicy(
      new PolicyStatement({
        actions: ["dynamodb:UpdateItem"],
        resources: [
          drsVolumeAnnotationsTable.tableArn,
          drsInstanceAnnotationsTable.tableArn,
        ],
      }),
    );

    // AWS Lambda function

    const subscriptionFilterLambda = new Function(this, "SubscriptionFilter", {
      runtime: Runtime.PYTHON_3_11,
      memorySize: 128,
      timeout: Duration.seconds(120),
      architecture: Architecture.ARM_64,
      description:
        "Process the outcome of malware scan operations for on-prem servers replicated with DRS",
      handler: "lambda_function.lambda_handler",
      code: Code.fromAsset(
        path.join(__dirname, "/../resources/lambda/SubscriptionFilter"),
      ),
      role: subscriptionFilterLambdaIamRole,
      layers: [drsHelperLayer],
      environment: {
        DDB_DRS_INSTANCE_ANNOTATIONS: drsInstanceAnnotationsTable.tableName,
        DDB_DRS_VOLUME_ANNOTATIONS: drsVolumeAnnotationsTable.tableName,
      },
    });

    const guardDutyStatusCWLogsFilterSubscription = new SubscriptionFilter(
      this,
      "GuardDutyStatusCWLogsFilterSubscription",
      {
        logGroup: LogGroup.fromLogGroupName(
          this,
          "GuardDutyMalwareScanLogGroup",
          "/aws/guardduty/malware-scan-events",
        ),
        destination: new LambdaDestination(subscriptionFilterLambda),
        filterPattern: FilterPattern.all(
          FilterPattern.stringValue(
            "$.eventDetails.eventType",
            "=",
            "EC2_SCAN_COMPLETED",
          ),
          FilterPattern.stringValue(
            "$.scanRequestDetails.requestType",
            "=",
            "ON_DEMAND",
          ),
          FilterPattern.stringValue(
            "$.resourceDetails.resourceType",
            "=",
            "EC2_INSTANCE",
          ),
        ),
      },
    );
  }
}
